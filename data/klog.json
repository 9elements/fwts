{
 "common_error_warning_patterns": 
 [ 
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS_THERMAL",
   "pattern": "Temperature above threshold, cpu clock throttled",
   "advice": "Test caused CPU temperature above critical threshold. Insufficient cooling?",
   "label": "CommonThermalOverrun"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "BIOS never enumerated boot CPU",
   "advice": "The boot processor is not enumerated!",
   "label": "CommonBiosBootCpuNotEnumerated"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_HOTPLUG",
   "pattern": "acpi_shpchprm.*_HPP fail",
   "advice": "Hotplug _HPP method failed",
   "label": "CommonAcpiHppMethodFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_HOTPLUG",
   "pattern": "shpchp.*acpi_pciehprm.*OSHP fail",
   "advice": "ACPI Hotplug OSHP method failed",
   "label": "CommonAcpiHotplugOshpMethodFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_HOTPLUG",
   "pattern": "shpchp.*acpi_shpchprm.*evaluate _BBN fail",
   "advice": "Hotplug _BBN method is missing",
   "label": "CommonAcpiHotPlugBbnMissing"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Error while parsing _PSD domain information",
   "advice": "_PSD domain information is corrupt!",
   "label": "CommonAcpiPsdParsingError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Wrong _BBN value, reboot and use option 'pci=noacpi'",
   "advice": "The BIOS has wrong _BBN value, which will make PCI root bridge have wrong bus number",
   "label": "CommonAcpiWrongBbnValue"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_APIC",
   "pattern": "ACPI.*apic on CPU.* stops in C2",
   "advice": "The local apic timer incorrectly stops during C2 idle state.The ACPI specification forbids this and Linux needs the local APIC timer to work. The most likely cause of this is that the firmware uses a hardware C3 or C4 state that is mapped to the ACPI C2 state.",
   "label": "CommonAcpiApicStopsInC2"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS_IRQ",
   "pattern": "Disabling IRQ",
   "advice": "The kernel detected an irq storm. This is most probably an IRQ routing bug.",
   "label": "CommonBiosIrqRoutingBug"
  }
 ],
 "firmware_error_warning_patterns":
 [
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": ", Invalid action",
   "advice": "The ACPI driver was requested to set a GPE wake mask with an incorrect action, expected ACPI_GPE_ENABLE or ACPI_GPE_DISABLE, see acpi_set_gpe_wake_mask(). This is most probably a kernel bug.",
   "label": "KlogAcpiGpeWakeMaskIncorrect"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid GPE Action,",
   "advice": "The ACPI driver was requested to enable or disable a single GPE in a parent enable register but was given an incorrect action, expected  ACPI_GPE_ENABLE or ACPI_GPE_DISABLE, see acpi_hw_low_set_gpe(). This is most probably a kernel bug.",
   "label": "KlogAcpiGpeActionInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unsupported address space: 0x",
   "advice": "The ACPI driver was requested to validate a H/W register but the address space ID was not ACPI_ADR_SPACE_SYSTEM_MEMORY or ACPI_ADR_SPACE_SYSTEM_IO.  Other address spaces are not supported by the driver. See acpi_hw_validate_register().",
   "label": "KlogAcpiHwRegsUnsupportedAddressSpace"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unsupported register bit width: 0x",
   "advice": "The ACPI driver was requested to validate a H/W register but the bit width of the register was not 8, 16 or 32 bits; other sizes are not suppoted by the driver. See acpi_hw_validate_register().",
   "label": "KlogAcpiHwRegsUnsupportedRegisterBitWidth"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid BitRegister ID: 0x",
   "advice": "The ACPI driver was requested the bitmask of a specific register ID which was greater than the the predefined driver maximum of ACPI_BITREG_MAX.  A NULL register info struct was passed back to the caller.  This is normally a driver bug, see acpi_hw_get_bit_register_info().",
   "label": "KlogAcpiHwRegsInvalidBitRegisterId"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown Register ID: 0x",
   "advice": "The ACPI driver was registed to read an ACPI register, but an invalid register ID was given; was expected withe a PM1 status register, PM1 enable register, PM1 control, PM 2 control, PM timer or a SMI command block.  This is normally a driver bug, see acpi_hw_register_read().",
   "label": "KlogAcpiHwRegsUnknownRegisterId"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "No handler or method for .*, disabling event",
   "advice": "A General Purpose Event (GPE) has occurred and there does not appear to be a GPE handler for this event.  This should no longer be possible with kernels dating after March 2010.  The GPE is disabled and will not occur until the machine is rebooted. See acpi_ev_gpe_dispatch().",
   "label": "KlogAcpiGpeHandlerMissing"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid SystemMemory width ",
   "advice": "The ACPI interpreter was requested to read or write to a memory region via a memory space handler but the requested field width was invalid. It expected a field with of 8, 16, 32 or 64 bits.  This is most probably an AML opregion bug.",
   "label": "KlogAcpiOpRegionInvalidSystemMemoryWidth"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not map memory at 0x.*, size",
   "advice": "The ACPI interpreter was requested to read or write to a memory region via a memory space handler but the logical address could not be mapped from the given physical address given.  This memory region is not mappable, so it could be an AML opregion bug or a bug in the kernel (less likely).",
   "label": "KlogAcpiOpRegionMemMapError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "32-bit FADT register is too long .* to convert to GAS struct - 255 bits max, truncating",
   "advice": "The Generic Address Structure bit_width was greater than 31 which is too large for a 32 bit ACPI FADT register and was truncated.  This is firmware bug.",
   "label": "KlogAcpiFadtGasBitWidthTooLong"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not install GPE interrupt handler at level 0x",
   "advice": "The ACPI driver attempted to install a General Purpose Event interrupt handler but this failed.  Is the interrupt available or already used? See acpi_ev_get_gpe_xrupt_block().",
   "label": "KlogAcpiGpeHandlerInstallFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown control opcode=0x.* Op=",
   "advice": "The ACPI interpreter could not execute an unknown AML opcode. This is an ACPI AML firmware bug.  See acpi_ds_exec_end_control_op().",
   "label": "KlogAcpiUnknownControlOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "No response from Global Lock hardware, disabling lock",
   "advice": "An attempt to send a global lock SMI did not generate a global lock event and so the kernel has concluded that the BIOS global lock handler is not functioning on this hardware.  All subsequent attempts to use the global lock will be flagged with an error.  You may experience race conditions in the ACPI driver.",
   "label": "KlogAcpiGlobalLockDisabled"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not signal Global Lock semaphore",
   "advice": "A global lock signal was sent to the firmware using a SMI but this failed to complete correctly.",
   "label": "KlogAcpiGlobalLockSignalError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid leading digit:",
   "advice": "An ACPI name started with a leading digit which is illegal. This is a bug in an ACPI table.",
   "label": "KlogAcpiNameLeadingDigit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Bad character 0x.* in name, at",
   "advice": "Am ACPI segment name started with some valid name characters but was shorted than the expected length of 4 characters.",
   "label": "KlogAcpiNameWrongSize"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Malformed Name at ",
   "advice": "An ACPI name had a valid prefix path but there wasn't a valid name following the prefix.",
   "label": "KlogAcpiMalformedName"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid/unknown Address Space ID: 0x",
   "advice": "The ACPI driver was attempting to create a new operation region objject as specified by an AML instruction but the provided Space ID was not one of the predefined IDs or in the user-defined range. The operation region is not created. This is an AML bug in the ACPI DSDT or SSDTs.",
   "label": "KlogAcpiAmlOpRegionInvalidAddressSpaceId"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Type returned from .* was incorrect: .*, expected Btypes: 0x",
   "advice": "The ACPI interpreter was evaluating a namespace object and discovered that the return type did not match the expected return type.  This is an ACPI AML bug in the ACPI DSDT or SSDTs.",
   "label": "KlogAcpiIncorrectReturnType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid/unsupported resource descriptor: Type 0x",
   "advice": "The ACPI interpreter failed to convert an AML resource into an aligned internal representation of the resource. The resource descriptor was not a recognised type that could be converted. This is an ACPI AML bug.",
   "label": "KlogAcpiInvalidResourceDescriptor"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid descriptor type .* in resource list",
   "advice": "The ACPI interpreter failed to convert a linked list of resources into an AML buffer because one of the resources had in invalid resource type. This may be a bug in the ACPI resource handling code.",
   "label": "KlogAcpiInvalidDescriptorType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Match operator out of range",
   "advice": "The ACPI interpreter found an AML match operator that was unrecognised, it was expecting MTR, MEQ, etc.  This is a bug in the AML.",
   "label": "KlogAcpiMatchOperatorOutOfRange"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Index .* beyond package end",
   "advice": "The ACPI interpreter was executing a 6 argument MATCH_OP op-code and discovered that the integer index being used fall outside of the package being referenced.  This is an index overflow or underflow error and is considered to be a bug in the AML.",
   "label": "KlogAcpiIndexOutOfPackageRange"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Table has invalid signature .* must be SSDT or OEMx",
   "advice": "The ACPI driver detected an ACPI table with an invalid signature. This table will not be loaded and will be ignored.",
   "label": "KlogAcpiInvalidTableSignature"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "The ACPI DSDT has been corrupted or replaced - old, new headers below",
   "advice": "The current loaded DSDT length and/or checksum differ to original version. This could be because it has been altered from outside Linux (perhaps broken firmware or a rootkit) or some incorrect memory write has corrupted the table. A workaround is to boot with the kernel parameter: acpi=copy_dsdt",
   "label": "KlogAcpiDsdtCorrupt"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid signature .* for ACPI table, expected .*",
   "advice": "The ACPI DSDT and FACS tables must have correct signatures otherwise the ACPI driver treats them as suspect or corrupt and will not load them.",
   "label": "KlogAcpiTableSignatureInvalid"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid table length .* in RSDT/XSDT",
   "advice": "The ACPI RSDT and XSDT must have the correct length. These variable length tables contain pointers to other ACPI tables and stated length that is different than the actual length can imply that the these tables are not trustworthy and hence the ACPI driver cannot tell if the pointers are totally valid or not.  The driver will ignore these tables and ACPI will be disabled.",
   "label": "KlogAcpiTableLengthInvalid"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Required FADT field .* has zero address and.*or length",
   "advice": "The ACPI FADT fields Pm1a_event, Pm1a_control, pm_timer are required fields that must have a defined (non-zero) address and a length that is non-zero.  One of these fields is incorrect and needs fixing.",
   "label": "KlogAcpiFadtFieldZeroAddrLength"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not convert AML resource",
   "advice": "The ACPI driver could not convert an AML resource to an internal representation of the resource that is aligned and easier to access. This is most likely to be because their is an unrecognised ACPI resource op-code.  See acpi_rs_convert_aml_to_resource() for details.",
   "label": "KlogAcpiAmlResourceConvertFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not convert resource",
   "advice": "The ACPI driver could not covert a resource linked list into an AML bytestream. See acpi_rs_convert_resources_to_aml() for details.",
   "label": "KlogAcpiResourceToAmlFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not get result from predicate evaluation",
   "advice": "The ACPI driver failed to pop a result off the result stack while evaluating a predicate. This is probably an AML code firmware bug.",
   "label": "KlogAcpiPredicateEvalPopFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "During .?egion initialization",
   "advice": "The ACPI driver failed to initialize a name space operation region. This is most probably the _REG (Region) control failed to evaluate.",
   "label": "KlogAcpiRegInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _PRS",
   "advice": "The ACPI driver failed to evaluate the _PRS (Possible Resource Settings) object. This failure will lead to a PCI link not being added to the system.",
   "label": "KlogAcpiPrsEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _CRS",
   "advice": "The ACPI driver failed to evaluate the _CRS (Current Resource Settings) object to get the current IRQ assignment. This failure will lead to a PCI link not allocating an IRQ.",
   "label": "KlogAcpiCrsEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _SRS",
   "advice": "The ACPI driver failed to evaluate the _SRS (Set Resource Settings) object to set the current link resource. This failure will lead to a
 PCI link not allocating an IRQ.",
   "label": "KlogAcpiSrsEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "While executing method",
   "advice": "The ACPI driver attempted to execute an ACPI sleep method but this failed to execute. This is most probably an ACPI firmware bug.",
   "label": "KlogAcpiSleepMethodFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Missing or null operand",
   "advice": "The ACPI driver got a missing or NULL operand while translating a parse tree object that is an argument to an AML object. This is more likely to be poorly written or compiled AML rather than an ACPI parser bug.",
   "label": "KlogAcpiParseMissingNullOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "While creating Arg ",
   "advice": "The ACPI driver failed to convert an operator's arguments from a parse tree format to a namespace object during the parse.",
   "label": "KlogAcpiOpArgCreateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _BST",
   "advice": "The ACPI driver attempted to get the ACPI battery state but the _BST (Battery Status) failed to evaluate. This is most likely to be a firmware or embedded controller bug. The ACPI battery state cannot be reported to userspace.",
   "label": "KlogAcpiBsrEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _PPC",
   "advice": "The ACPI driver attempted to get the current CPU performance states but the _PPC (Performance Present Capabilities) method failed to evaluate. The CPU frequency policy will not be updated.  This may explain why CPU frequencies are locked at one setting and do not change.",
   "label": "KlogAcpiPpcEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _PCT",
   "advice": "The ACPI driver attempted to get the CPU performance control and status registers but the _PCT (Performance Control) object failed to evaluate. This error normally occurs because the BIOS is an old or that it does not know the CPU frequencies.  CPU frequency support is not supported.",
   "label": "KlogAcpiPctEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _PSS",
   "advice": "The ACPI driver attempted to get the CPU performance states bug the _PSS (Performance Supported States) object failed to evaluate. This error normally occurs because the BIOS is an old or that it does not know the CPU frequencies.  CPU frequency support is not supported.",
   "label": "KlogAcpiPssEvalFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Failed to write pstate_control .* to smi_command",
   "advice": "The ACPI driver attempted to update the P states but the P state control command written to the SMI command port failed to write.  This could be because that ACPI FADT SMI command or FADT P State control settings are incorrect, or that the port write just failed (which is very unlikely).",
   "label": "KlogAcpiPstateControlSmiCommandFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_EMBEDDED_CONTROLLER",
   "pattern": "AE_TIME.*Returned by Handler for.*[EmbeddedControl]",
   "advice": "This is most probably caused by when a read or write operation to the EC memory has failed because of a timeout waiting for the Embedded Controller to complete the transaction.  Normally, the kernel waits for 500ms for the Embedded Controller status port to indicate that a transaction is complete, but in this case it has not and a AE_TIME error has been returned. ",
   "label": "KlogAcpiTimeOutReturnedByHandler"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Returned by Handler for",
   "advice": "The ACPI driver detected an error returned by a region handler.",
   "label": "KlogAcpiRegionHandlerError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "from region _REG",
   "advice": "The ACPI driver detected an error when attempting to execute an ACPI_REG_DISCONNECT on a _REG (Region) method.",
   "label": "KlogAcpiRegDisconnectFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "from region handler - deactivate",
   "advice": "The ACPI driver detected an error when attempting to deactivate a region. This error is ignored.",
   "label": "KlogAcpiRegDeactivateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "While resolving operands for",
   "advice": "The ACPI driver found not resolve an operand for the AML AML_DECREMENT_OP (0x76) or AML_INCREMENT_OP (0x75) instructions. This is due to buggy AML code and not a ACPI driver bug.",
   "label": "KlogAcpiIncDecNoOperands"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not update object reference count",
   "advice": "The ACPI driver failed to update the reference count to an internal ACPI object. Reference counts are incremented when an object is attached to a node or an object is copied and decremented when an object is detected from a node.  This failure will lead to object garbage collection failing to operate correctly. This is considered a kernel bug.",
   "label": "KlogAcpiObjRefCountError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not write ACPI mode change",
   "advice": "The ACPI driver attempted to inform the firmware (via a System Management Interrupt) that the machine was transitioning to or from ACPI or legacy mode but this failed. This normally indicates that either SMIs are failing or the firmware is buggy. Normally if this fails to transition to ACPI mode then ACPI is not enabled.",
   "label": "KlogAcpiModeChangeFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "During name lookup/catalog",
   "advice": "The ACPI driver failed to find an object while parsing a named Op, see acpi_ps_build_named_op().",
   "label": "KlogAcpiNamedObjLookupFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invoked method did not return a value",
   "advice": "An invoked ACPI method did not return a value but it was expected to. This could lead to unexpected ACPI execution behaviour.",
   "label": "KlogAcpiMethodNoReturnValue"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "GetPredicate Failed",
   "advice": "The ACPI driver failed to get a predicate for the AML opcodes IF or WHILE. This normally is because of faulty AML code.",
   "label": "KlogAcpiIfWhilePredicateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not create predefined name",
   "advice": "The ACPI driver was initializing the ACPI namespace and adding pre-defined names but this failed on this particular object. This should not happen.",
   "label": "KlogAcpiPredefinedNameCreateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "While loading namespace from ACPI tables",
   "advice": "The ACPI driver failed to load the namespace from the DSDT and SSDTs/PSDTs found in the RSDT/XDSDT. This will lead to the ACPI driver being disabled.",
   "label": "KlogAcpiNameSpaceLoadFailure"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "While evaluating SleepState .* bad Sleep object .* type .*",
   "advice": "The ACPI driver failed to evaluate an ACPI sleep control while trying to obtain the SLP_TYPa and SLP_TYPb values for the requested sleep state.",
   "label": "KlogAcpiSlpEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "while handling a GPE",
   "advice": "The ACPI driver attempted to asynchronously execute an ACPI General Purpose Event (GPE) but this failed because the kernel ran out of free memory to allocate a GPE event information buffer.  The event was not handled, this may lead to unpredictable behaviour.",
   "label": "KlogAcpiGpeNoMemory"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "while evaluating GPE method",
   "advice": "The ACPI driver attempted to asynchronously execute an ACPI General Purpose Event (GPE) but the ACPI GPE method failed for some unknown reason. This is most likely a firmware bug.",
   "label": "KlogAcpiGpeEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to clear GPE",
   "advice": "An edge triggered ACPI General Purpose Event (GPE) occurred and the clearing of the GPE status bit failed. This is normally a low-level hardware I/O register write failure. This may lead to this GPE failing to be handled again.",
   "label": "KlogAcpiGpeClearFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to disable GPE",
   "advice": "An ACPI General Purpose Event (GPE) could not be disabled.  These are disabled to ensure the GPE does not keep firing before the asynchronous GPE handler completes.  The failure to disable the GPE may lead to further GPEs being triggered and causing some unexpected handling failures.",
   "label": "KlogAcpiGpeDisableFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to queue handler for GPE",
   "advice": "The ACPI driver failed to dispatch the GPE asynchronously. The GPE will not be properly handled and will be ignored.",
   "label": "KlogAcpiGpeQueueHandlerFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "During OSL initialization",
   "advice": "The ACPI driver failed to initialize, the kernel specific OS dependent layer failed to initialize. This is a kernel bug and ACPI will be disabled.",
   "label": "KlogAcpiOsLayerInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "During initialization of globals",
   "advice": "The ACPI driver failed to initialize, could not initialize the globals used by the subsystem. This is a kernel bug and ACPI will be disabled.",
   "label": "KlogAcpiGlobalsInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "During Global Mutex creation",
   "advice": "The ACPI driver failed to initialize, could not initialize the global mutex. This is a kernel bug and ACPI will be disabled.",
   "label": "KlogAcpiGlobalMutexInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "During Namespace initialization",
   "advice": "The ACPI driver failed to initialize, could not initialize the ACPI global namespace manager and root namespace tree. ACPI will be disabled.",
   "label": "KlogAcpiNamespaceInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "During OSI interfaces initialization",
   "advice": "The ACPI driver failed to initialize, could not initialize the ACPI OSI interfaces. ACPI will be disabled.",
   "label": "KlogAcpiOsiInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not create GPE Block 0",
   "advice": "The ACPI driver failed intialize the General Purpose Events (GPE) Block 0. This means that GPEs for this block will be not handled and so some devices or controls may not work correctly.",
   "label": "KlogAcpiGpeBlock0InitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not create GPE Block 1",
   "advice": "The ACPI driver failed intialize the General Purpose Events (GPE) Block 1. This means that GPEs for this block will be not handled and so some devices or controls may not work correctly.",
   "label": "KlogAcpiGpeBlock1InitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "While decoding _Lxx/_Exx methods",
   "advice": "The ACPI driver failed to decode level _Lxx or edge _Exx methods for newly added ACPI tables.",
   "label": "KlogAcpiGpeLevelOrEdgeMethodDecodeFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not enable GPE 0x",
   "advice": "The ACPI driver failed to enable a General Purpose Event (GPE).  A GPE event handler will not be executed for this GPE and this may mean some form of loss of functionality with specific devices.",
   "label": "KlogAcpiGpeEnableFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Processor Device is not present",
   "advice": "The ACPI driver has responded to an ACPI processor hotplug event and attempted to execute the _STA (Status) control for a processor but this failed. _STA is mandatory for a processor that supports hot plug and so the driver has not added the processor to the running system.",
   "label": "KlogAcpiCpuHotPlugStaFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not install PciConfig handler for Root Bridge",
   "advice": "The ACPI driver could not install a PCI Config operation region for a PCI Root Bridge. This could occur for a variety of reasons but it is most probably because the devices _REG (Region) control failed.",
   "label": "KlogAcpiPciConfigInstallFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "During WalkNamespace",
   "advice": "The ACPI driver failed to traverse the ACPI namespace either during namespace initialization. ACPI will be disabled. ",
   "label": "KlogAcpiWalkNamespaceFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "During device initialization",
   "advice": "The ACPI driver failed to traverse the ACPI namespace and initialize all the ACPI devices.",
   "label": "KlogAcpiNsDevInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not execute arguments for",
   "advice": "The ACPI driver failed to initialize methods or op regions during the namespace traversal.",
   "label": "KlogAcpiNsExecArgFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI thermal trip point .* changed",
   "advice": "The ACPI driver has thrown this exeption because of one of the two cases: 1. Either a trip point has becomes invalid when re-evaluating the AML code or, 2. devices listed in _PSL, _ALx or _TZD may have changed and the driver needs to re-bind to the cooling devices of a thermal zone when that happens.  This execption probably means the ACPI thermal driver needs to cater for this behaviour and it needs fixing or updating.",
   "label": "KlogAcpiThermTripPointChanged"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Cannot find acpi parent",
   "advice": "The ACPI driver was attempting to notify a memory device but could not find a parent to the given device handle. This is an internal ACPI driver error and should not occur.  ACPI memory hotplug failures may occur because of this failure.",
   "label": "KlogAcpiMemHotPlugParentError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_EJ0 failed",
   "advice": "The ACPI driver attempted to power down a memory hot plug device but the ACPI _EJ0 (Eject) control failed which leaves the hotplug memory device in an invalid state.",
   "label": "KlogAcpiMemHotPlugEj0Failed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "walk_namespace failed",
   "advice": "The ACPI driver failed to traverse the ACPI object namespace to allow it to register any memory hotplug notify handlers. This failure means that ACPI memory hotplug will not work.",
   "label": "KlogAcpiMemHotPlugInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "failed to execute _DCK",
   "advice": "The ACPI driver executed the _DCK (Dock) control but this failed to complete successfully. This control is executed when an ACPI docking or undocking event is received.  This may be because of a fault _DCK control or that the hardware isn't functioning correctly.",
   "label": "KlogAcpiDckEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _DOD",
   "advice": "The ACPI driver failed to enumerate the ACPI video devices because the _DOD (Enumerate All Devices Attached to the Display Adapter) control failed.  This may explain why the video device is not functioning correctly.",
   "label": "KlogAcpiDodEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid _DOD data",
   "advice": "The ACPI control _DOD (Enumerate All Devices Attached to the Display Adapter) returned either a NULL package or not did not return an ACPI_PACKAGE type as expected.  This may explain why the video device is not functioning correctly.",
   "label": "KlogAcpiDodInvalidData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid GPE 0x",
   "advice": "The ACPI driver was requested to get the status of a ACPI General Purpose Event or Fixed Event that did not exist. This is an unexpected driver error.",
   "label": "KlogAcpiInvalidGpe"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _PRT",
   "advice": "The ACPI driver failed to get the PCI Routing Table for a device because the evaluation of _PRT (PCI Routing Table) failed. This will lead to the device not having the IRQ wired up to the correct slot/device/pin. Without this, the device cannot handle interrupts and will fail to work. ",
   "label": "KlogAcpiPrtEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Attempted physical table override failed",
   "advice": "The ACPI driver attempted to physically map an ACPI table but this failed.  This table will not be used and this can lead to unexpected behaviour and loss of functionality.",
   "label": "KlogAcpiTablePhysMapFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not acquire Global Lock",
   "advice": "The ACPI Global Lock is a mutex that ensures exclusive access to resources controlled by the ACPI driver. This lock failed to be acquired which normally means that the kernel mutex has failed, which should never occur.  This is normally considered a kernel bug.",
   "label": "KlogAcpiGlobalLockAcquireFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not release Global Lock",
   "advice": "The ACPI Global Lock is a mutex that ensures exclusive access to resources controlled by the ACPI driver. This lock failed to be release which normally means that the kernel mutex has failed, which should never occur.  This is normally considered a kernel bug.",
   "label": "KlogAcpiGlobalLockReleaseFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Error reading AC Adapter state",
   "advice": "The ACPI driver could not read the AC adapter state because the ACPI control _PSR (Power Source) failed to evaluate. This could be because this control did not exist or more probably that it failed to execute because of an error between the firmware and the smart battery.",
   "label": "KlogAcpiPsrEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _TPC",
   "advice": "The ACPI driver failed to get the current number of supported CPU throttling T States because the ACPI control _TPC (Throttling Present Capabilities) failed to evaluate.",
   "label": "KlogAcpiTpcEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _PTC",
   "advice": "The ACPI driver failed to get the Processor Throttling Control because the ACPI control _PTC failed to evaluate. This option control defines a processor throttling control interface alternative to the I/O address spaced-based P_BLK throttling control register (P_CNT).  Without this the CPU cannot be throttled via this interface.",
   "label": "KlogAcpiPtcEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _TSS",
   "advice": "The ACPI driver failed to get the Throttling Supported States because the ACPI control _TSS failed to evaluate. Processor throttling will not be enabled.",
   "label": "KlogAcpiTssEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid _TSS data: freq is zero",
   "advice": "The ACPI driver got invalid data from the ACPI control _TSS (Throttling Supported States). One of the CPU throttling frequencies in the _TSS package is zero, which is invalid. Processor throttling will not be enabled.",
   "label": "KlogAcpiTssPackageFreqZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid _TSS data",
   "advice": "The ACPI driver got invalid data from the ACPI control _TSS (Throttling Supported States). Either the package was NULL or the data returned was not of type ACPI_PACKAGE.",
   "label": "KlogAcpiTssPackageInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _TSD",
   "advice": "The ACPI driver could not get the T-State Dependency from the ACPI control _TSD. This means that the CPU will not have any throttling coordination with other CPUs",
   "label": "KlogAcpiTsdEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid _TSD data",
   "advice": "The ACPI driver got invalid data from the ACPI control _TSD (T-State Dependency). Either the package was NULL or the data returned was not of type ACPI_PACKAGE or the number of elements in the package was incorrect or the package in element zero could not be extracted.",
   "label": "KlogAcpiTsdDataInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _PRW",
   "advice": "The ACPI driver failed to evaluate the ACPI control _PRW (Power Resources for Wake). As a result, wakeup device management will not function.",
   "label": "KlogAcpiPrwEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Extracting _PRW package",
   "advice": "The ACPI driver got invalid data from the ACPI control _PRW (Power Resources for Wake). The returned data did not conform to the ACPI specification, see section 7.2.13 of the ACPI 5.0 ACPI specification for more details.",
   "label": "KlogAcpiPrwDataInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Notifying BIOS of _CST ability failed",
   "advice": "The ACPI driver attempted to notify the firmware (using a System Management Interrupt) that the system had _CST (C-State) ability but this notify command failed. This may lead to unexpected C-State behaviour.",
   "label": "KlogAcpiSmiCstFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating _PIC",
   "advice": "The ACPI driver attempted to inform the firmware which method of interrupt routing was being used via the _PIC method, however, this failed to execute.  This results in ACPI being disabled.",
   "label": "KlogAcpiPicEvalFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Mutex .* is not acquired, cannot release",
   "advice": "An attempt to release (unlock) an ACPI related mutex has occurred. This mutex could not be released. This is most probably a bug in the AML code where a Release opcode has been executed that does not match up with an earlier corresponding Mutex opcode. It may also be a bug in the ACPI driver, but this is less likely.",
   "label": "KlogAcpiMutexReleaseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Thread .* could not acquire Mutex",
   "advice": "A mutex could not be acquired (locked) and the ACPI driver has flagged this up as an exception error. If this occurs when executing a AML Mutex opcode there could be race condition errors if the AML is not checking the return from the Mutex operation and a lot of firmware does omit this check.",
   "label": "KlogAcpiMutexAcquireError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to initialize fixed events",
   "advice": "The ACPI driver failed to initialize the structure that keeps track of fixed event handlers.  The failure occurred when trying to disable one of the 4 fixed events and this causes the ACPI subsystem initialization to fail, which disables ACPI support.",
   "label": "KlogAcpiFixedEventInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to initialize general purpose events",
   "advice": "The ACPI driver failed to initialize the General Purpose Event (GPE) blocks as defined in the ACPI FADT. This in turn causes the ACPI subsystem initialization to fail, which disables ACPI support.",
   "label": "KlogAcpiGpeInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to install System Control Interrupt handler",
   "advice": "The ACPI driver failed to install the System Control (SCI) interrupt handler, which has to be working for ACPI to work correctly. This in turn causes the ACPI subsystem initialization to fail, which disables ACPI support.",
   "label": "KlogAcpiSciHandlerInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to initialize Global Lock handler",
   "advice": "The ACPI driver failed to initialized the Global Lock handler, which is basically a kernel mutex (and should not fail). This in turn causes the ACPI subsystem initialization to fail, which disables ACPI support.",
   "label": "KlogAcpiGlobalLockInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "No installed handler for fixed event",
   "advice": "The ACPI driver failed to dispatch a fixed event because their is no fixed event handler installed for this event. This is an error and the kernel has disabled this event for further interrupts. This could lead to reduced functionality.",
   "label": "KlogAcpiNoFixedEventHandler"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Index .* is beyond end of object",
   "advice": "The ACPI interpreter could not execute an AML index opcode, the index in the first operand is out of range.",
   "label": "KlogAcpiIndexOverflow"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unexpected notify object type",
   "advice": "The ACPI interpreter could not execute a AML notify opcode because the first operand is not a notify object.  This is a bug in the firmware.",
   "label": "KlogAcpiUnexpectedNotifyObjType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Sleep values out of range: A=.* B=.*",
   "advice": "An attempt to transition to a sleep state has occurred with the ACPI sleep type values for the PM controls set greater than the maximum allowed value of 7. This is an illegal value and the system will not be transistioned to this sleep state. ",
   "label": "KlogAcpiSleepValuesRangeError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown exception code: 0x",
   "advice": "An execption occurred but the execption code was not recognized and the ACPI driver could not find a textual description for this exception. This is most probably a bug in the ACPI driver or ACPICA core.",
   "label": "KlogAcpiUnknownExceptionCode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid type .* for target of Scope operator .*Cannot override",
   "advice": "The ACPI interpreter found an invalid type for target of a scope operator, this occurred during the loading of the ACPI tables, see acpi_ds_load2_begin_op().",
   "label": "KlogAcpiInvalidTypeScopeOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Divide by zero",
   "advice": "The ACPI interpreter detected a zero divisor which produce a division by zero error.  The AML code is buggy and this will return an undefined value that may cause unexpected behaviour.",
   "label": "KlogAcpiAmlDivideByZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not release AML Interpreter mutex",
   "advice": "The ACPI AML interpreter attempted to release the mutex but this failed. The next time interpreter will attempt to acquire this mutex it will fail, however it will continue to execute AML but there will be race conditions occurring.",
   "label": "KlogAcpiAmlMutexNotReleased"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Could not map memory at 0x.* for length",
   "advice": "ACPI could not memory map the Extended BIOS Data Area (EBDA) or upper region 0xE0000-0xFFFFF to search for the ACPI RSDP.  This normally results in the RSDP not being found, which means the ACPI tables can't be located and hence ACPI is disabled.",
   "label": "KlogAcpiRsdpMemMap"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid zero ID from AcpiOsGetThreadId",
   "advice": "A zero thread ID was returned which will break the ACPI driver.  This should never happen, since the thread ID is actually the address of the thread descriptor which is never zero.",
   "label": "KlogAcpiZeroThreadId"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown action (0x",
   "advice": "The ACPI engine was expecting to increment, decrement or delete a reference count but instead was given an uknown action to do instead.  This is a bug in the ACPI ACPICA code.",
   "label": "KlogAcpiRefCountUnknownAction"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Null Op",
   "advice": "The ACPI interpreter found a NULL parse opcode and didn't expect to. See acpi_ds_delete_result_if_not_used() or acpi_ds_is_result_used().",
   "label": "KlogAcpiNullOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown parent opcode Op=",
   "advice": "The ACPI interpreter found an AML opcode that had an unexpected parent class. This probably indicates an internal ACPI interpeter bug. ",
   "label": "KlogAcpiUnknownParentOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Time parameter is too large",
   "advice": "ACPI Stall() op was requested to wait for more than 255 usec.  The ACPI specification states that the maximum should be 100 usec but to accommodate some firmware a maximum of 255 is supported by the kernel.",
   "label": "KlogAcpiStallTooLarge"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BRIGHTNESS",
   "pattern": "Evaluating _BCM failed",
   "advice": "Could not set the brightness level, the ACPI control _BCM failed to execute correctly.",
   "label": "KlogAcpiBcmFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BRIGHTNESS",
   "pattern": "Current brightness invalid",
   "advice": "The ACPI video driver set the brightness level using the ACPI control _BCM, however the level used was not a known level (as returned by _BCL).",
   "label": "KlogAcpiInvalidBrightness"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Too many duplicates in _BCL package",
   "advice": "ACPI method _BCL (Query List of Brightness Control Levels Supported) contains too many duplicated brightness levels in the returned package and this is non-standard.",
   "label": "KlogAcpiBclPackageContainsDuplicates"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Found unordered _BCL package",
   "advice": "ACPI method _BCL (Query List of Brightness Control Levels Supported) has a maximum brightness value which is not the last value in the returned package. Values returned must be in ascending order.",
   "label": "KlogAcpiBclUnorderedPackage"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI Subsystem is already terminated",
   "advice": "A request to terminate the ACPI driver but it is already terminated. You should not see this error.",
   "label": "KlogAcpiAlreadyTerminated"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Null scope parameter",
   "advice": "Failed to push the current scope onto the scope stack, the node was Null, which was not expected. See acpi_ds_scope_stack_push().",
   "label": "KlogAcpiNullScopeParameter"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid conversion sub-opcode",
   "advice": "The ACPI driver could not convert an AML resource descriptor to a corresponding internal resource descriptor. Refer to acpi_rs_convert_aml_to_resource() or acpi_rs_convert_resource_to_aml().",
   "label": "KlogAcpiConversionSupOpcode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid conversion opcode",
   "advice": "The ACPI driver could not convert an AML resource descriptor to a corresponding internal resource descriptor. Refer to acpi_rs_convert_aml_to_resource() or acpi_rs_convert_resource_to_aml().",
   "label": "KlogAcpiConversionSupOpcode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "No SMI_CMD in FADT, mode transition failed",
   "advice": "ACPI FADT SMI_CMD is zero, with ACPI 2.0 this means that the system cannot transtion to/from ACPI mode.",
   "label": "KlogAcpiFadtSmiCmdZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "No ACPI mode transition supported in this system (enable/disable both zero)",
   "advice": "ACPI FADT ACPI_ENABLE is zero and ACPI_DISABLE is set, ACPI 2.0 this means enabling or disabling is not supported and the system cannot transition to ACPI mode.",
   "label": "KlogAcpiNoModeTransitionSupport"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Found a grandchild.*P=.*C=",
   "advice": "An error occured in the ACPI driver, acpi_ns_delete_children() was trying to delete children objects and discovered that one of these had children objects of it's own, which should not happen.",
   "label": "KlogAcpiObjectGrandchild"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Cannot assign type .* to .*must be type Int/Str/Buf",
   "advice": "ACPI execution run time error: Type assignment was illegal, acpi_ex_resolve_object() was trying assign a type to a different type which is illegal.",
   "label": "KlogAcpiTypeAssign"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Store into an unresolved Alias object",
   "advice": "ACPI execution run time error: The ACPI driver has been asked to resolve an object of type ACPI_TYPE_LOCAL_ALIAS or ACPI_TYPE_LOCAL_METHOD_ALIAS but this should not occur as these should have been resolved earlier. See function acpi_ex_resolve_object() for more details.",
   "label": "KlogAcpiUnresolveAliasObject"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown AML opcode 0x",
   "advice": "ACPI execution run time error: The ACPI interpreter has reached an opcode that is unknown, this normally is a bug in the underlying AML code either because of badly written AML code or the compiler has produced code that is incorrect or the ACPI interpreter does not support this valid opcode. ",
   "label": "KlogAcpiUnknownAmlOpcode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid AML Opcode: 0x",
   "advice": "ACPI execution run time error: The ACPI interpreter has reached an opcode that is unknown, this normally is a bug in the underlying AML code either because of badly written AML code or the compiler has produced code that is incorrect or the ACPI interpreter does not support this valid opcode. ",
   "label": "KlogAcpiUnknownAmlOpcode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Found unknown opcode .* at AML address .* offset",
   "advice": "ACPI execution run time error: The ACPI interpreter has reached an opcode that is unknown, this normally is a bug in the underlying AML code either because of badly written AML code or the compiler has produced code that is incorrect or the ACPI interpreter does not support this valid opcode. ",
   "label": "KlogAcpiUnknownAmlOpcode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "BCD digit too large (not decimal): 0x",
   "advice": "ACPI execution run time error: AML opcode AML_FROM_BCD_OP (0x5b28) contains a BCD digit value that is greater than 9 and is out of range for a Binary Coded Decimal digit.",
   "label": "KlogAcpiBcdDigitTooLarge"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Integer too large to convert to BCD",
   "advice": "ACPI execution run time error: AML opcode AML_TO_BCD_OP (0x5b29) has been requested to convert an integer into a Binary Coded Decimal value that is too large. An overflow has been caught and it is possible that unexpected execution behaviour will occur.",
   "label": "KlogAcpiToBcdOverflow"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "obsolete and not implemented",
   "advice": "ACPI execution run time error: Execution of AML_SHIFT_LEFT_BIT_OP (0x5b11) or AML_SHIFT_RIGHT_BIT_OP (0x5b10) were ignored, these are obsolete AML opcodes and are not implemented in the ACPI interpreter. Unexepcted execution behaviour will occur.",
   "label": "KlogAcpiOpObsolete"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Operand must be Buffer/Integer/String/Package - found type",
   "advice": "ACPI execution run time error: Execution of AML_SIZE_OF_OP with an operand that is not a buffer, integer, string or package has occurred. This will result in unexpected behaviour. This is a bug in the AML.",
   "label": "KlogAcpiOpTypeBad"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown Index TargetType 0x",
   "advice": "ACPI execution run time error: Execution of AML_DEREF_OF_OP (0x83) with an illegal target index operator that was not a buffer or a package type.",
   "label": "KlogAcpiUnknownIndexTargetType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown class in reference",
   "advice": "ACPI execution run time error: Execution of AML_DEREF_OF_OP (0x83) with an illegal operand reference class.",
   "label": "KlogAcpiUnknownIndexTargetType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "apm.*an event queue overflowed",
   "advice": "More then 20 APM events were queued up which is unexpected.  The queue was not being drained quickly by a reading process (perhaps it is not running).",
   "label": "KlogApmEventQueueOverflow"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "apm.*passed bad filp",
   "advice": "A read of the APM events was performed by a reading process with an unrecognised file pointer. This should not happen.",
   "label": "KlogApmReadBadFileptr"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "apm.*filp not in user list",
   "advice": "An attempt to release a APM reader occurred using an unrecognised file pointer. This should not happen.",
   "label": "KlogApmReleaseBadFileptr"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "apm.*cannot allocate struct of size %d bytes",
   "advice": "An attempt to open failed, out of memory. APM events cannot be read.",
   "label": "KlogApmOpenNoMemory"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "apm.*disabled - Unable to start kernel thread",
   "advice": "Cannot start kernel APM thread, APM handling will be disabled.",
   "label": "KlogApmKernelThreadFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "PnPBIOS.*ESCD size reported by BIOS escd_info call is too great",
   "advice": "The ESCD size was greater than a sane size of 32K.",
   "label": "KlogPnpBiosEscdSize"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "PnPBIOS.*ESCD size reported by BIOS read_escd call is too great",
   "advice": "The ESCD size was greater than a sane size of 32K.",
   "label": "KlogPnpBiosEscdSize"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "PnPBIOS.*",
   "advice": "The PnPBIOS driver has detected an issue that fwts does not know about.",
   "label": "KlogPnpBiosError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Node number .* is out of sequence following node .* Aborting.",
   "advice": "Device node numbers are out of sequence.",
   "label": "KlogPnpBiosDevNodeSeqError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "PCI: BIOS BUG #",
   "advice": "A call to the PCI BIOS32 service routine (with service signature $PCI) has returned a bad status or an illegal PCI signature. The kernel will disable the use of the PCI BIOS.",
   "label": "KlogBios32PciFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "e820: too many entries; ignoring ",
   "advice": "Legacy E820 BIOS has a limit of 128 entries in the E820 memory map but the firmware seems to have more than this. For EFI Numa hardare, the limit is 128 + 3 * maximum number of nodes.  The kernel has ignore the extra entries.  This could lead to regions of memory being used by the kernel when in fact is should be reserved and this can lead to unexpected behaviour.",
   "label": "KlogE820TooManyEntries"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Ooops! Too many entries in the memory map!",
   "advice": "Legacy E820 BIOS has a limit of 128 entries in the E820 memory map but the firmware seems to have more than this. For EFI Numa hardare, the limit is 128 + 3 * maximum number of nodes.  The kernel has ignore the extra entries.  This could lead to regions of memory being used by the kernel when in fact is should be reserved and this can lead to unexpected behaviour.",
   "label": "KlogE820TooManyEntries"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_LOW",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "MTRR.*CPU.*SYSCFG.*MtrrFixDramModEn.*not cleared by BIOS, clearing this bit",
   "advice": "The firmware is expected to clear MtrrFixDramModEn bit, see for example BIOS and Kernel Developer's Guide for the AMD Athlon 64 and AMD Opteron Processors (26094 Rev. 3.30 February 2006), section 13.2.1.2 SYSCFG Register. The MtrrFixDramModEn bit should be set 1 during firmware initalization of the fixed MTRRs, then cleared to 0 for operation. Hence the kernel has detected and worked around this fault.",
   "label": "KlogMtrrFixDramModEnNotClear"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "MTRR.*CPU.*Writing MSR .* to .* failed",
   "advice": "Writing to a MTRR MSR has failed. The kernel cannot do much about this and has ignored the failure.",
   "label": "KlogMtrrWriteMsrFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "acpi_request_vector.*invalid interrupt type",
   "advice": "An attempt to request an interrupt vector greater than 256 (ACPI_MAX_PLATFORM_INTERRUPTS) has occurred and will be rejected.",
   "label": "KlogAcpiIa64RequestBadVector"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Can't find MADT",
   "advice": "Could not find the ACPI MADT. The kernel could not find this table so it could determine how many CPUs the system had.  The machine will boot with just one CPU which may be the incorrect number of CPUs.",
   "label": "KlogAcpiMadtMissing"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Error parsing MADT - no LAPIC entries",
   "advice": "The ACPI MADT could not be parsed to determine the number of Local APIC entries.  This may lead to sub-optimal configuration of the machine.",
   "label": "KlogAcpiMadtLapicParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Error parsing LAPIC address override entry",
   "advice": "The ACPI MADT could not be parsed to determine the Local APIC override entry.",
   "label": "KlogAcpiMadtLapiceOverrideParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Error parsing LAPIC NMI entry",
   "advice": "The ACPI MADT could not be parsed to determine the Local APIC NMI entry.",
   "label": "KlogAcpiMadtLapicNmiParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Error parsing MADT.*no IOSAPIC entries",
   "advice": "The ACPI MADT could not be parsed to find the IOSAPIC entries.",
   "label": "KlogAcpiMadtIosapicParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Error parsing platform interrupt source entry",
   "advice": "The ACPI MADT could not be parsed to find the platform intrerrupt source entry.",
   "label": "KlogAcpiMadtPlatIntSrcParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Can't find FADT",
   "advice": "The ACPI Fixed ACPI Description Table (FADT) is missing and so the kernel cannot determine if the legacy keyboard controller is present.  It cannot also determine the SCI_INT interrupt line which is used for ACPI events, such as the power and sleep buttons. If the SCI_INT is not on a legacy interrupt then it needs to be specified in the FADT. ",
   "label": "KlogAcpiFadtMissing"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Cannot create",
   "advice": "The ACPI driver attempted to create an entry in /proc/acpi but failed. This should not happen and is a kernel bug.",
   "label": "KlogAcpiProcfsCreateFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Create sysfs link",
   "advice": "The ACPI driver attempted to create a sysfs link for a device and this failed. This should not happen and is a kernel bug.",
   "label": "KlogAcpiSysfsLinkCreateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Error updating fan power state",
   "advice": "Failed to update the fan power state when coming out of resume. The call to acpi_bus_update_power() failed even though the fan device was valid.",
   "label": "KlogAcpiFanResumeUpdate"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "does not support this state",
   "advice": "A request to suspend the machine was aborted because it was asked to transition to a sleep state that is not supported by the ACPI driver or this machine.",
   "label": "KlogAcpiUnsupportedSleepState"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Hardware changed while hibernated, cannot resume",
   "advice": "The FACS hardware signature has changed when coming out of hibernation. The kernel has concluded that the machine has changed and therefore won't commit to resuming from hibernate.",
   "label": "KlogAcpiS4ResumeBadFacsSignature"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Device don't exist, dropping EJECT",
   "advice": "A processor hotplug notify eject request event was rejected because the device does not seem to exist.",
   "label": "KlogAcpiHotPlugEjectMissingDevice"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Driver data is NULL, dropping EJECT",
   "advice": "A processor hotplug notify eject request event was rejected because the device data is NULL.",
   "label": "KlogAcpiHotplugEjectNullDeviceData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid reference to IOAPIC pin",
   "advice": "The IOAPIC pin was invalid, it exceeded the maximum expected pin reference value (MP_MAX_IOAPIC_PIN 127).",
   "label": "KlogAcpiIoApicPinRefInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Error parsing IOAPIC entry",
   "advice": "Failed to parse the ACPI MADT, the number of IOAPIC entries found was less than zero, which probably means the MADT is broken.",
   "label": "KlogAcpiMadtParseError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "No IOAPIC entries present",
   "advice": "The ACPI MADT was expected to contain at least one IOAPIC entry, however, none were found. Cannot enumerate the IOAPICs.",
   "label": "KlogAcpiMadtNoIoApicEntry"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Error parsing interrupt source overrides entry",
   "advice": "Could not parse the ACPI MADT to determine the interrupt override for the SCI. This could lead to unexpected behaviour.",
   "label": "KlogAcpiMadtIrqOverrideParseError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Error parsing NMI SRC entry",
   "advice": "Could not parse the ACPI MADT to determine the NMI SRC entry. This could lead to unexpected behaviour.",
   "label": "KlogAcpiMadtNmiSrcEntryParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "pci_create_slot returned",
   "advice": "A PCI slot could not be register because a call to pci_create_slot() failed.",
   "label": "KlogAcpiPciSlot"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "walk_p2p_bridge failure",
   "advice": "Traversing the PCI root bridge failed because of an error walking the P2P bridge.",
   "label": "KlogAcpiPciSlot"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "register_slot failure",
   "advice": "Adding a PCI slot failed because traversing the PCI root bridge failed.",
   "label": "KlogAcpiPciSlot"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_PRS resource type .* isn't an IRQ",
   "advice": "The ACPI _PRS resource type was expected to be an IRQ type and was not.",
   "label": "KlogAcpiPciLinkPrsIrq"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_CRS resource type 0x%x isn't an IRQ",
   "advice": "The ACPI _CRS resource type was expected to be an IRQ type and was not.",
   "label": "KlogAcpiPciLinkCrsIrq"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to read status",
   "advice": "A query of _STA to get the bus status failed and the current link status is unknown.",
   "label": "KlogAcpiPciLinkSta"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_CRS returned 0",
   "advice": "The query of the bus status failed because the _CRS controlled returned IRQ 0, which was not expected.",
   "label": "KlogAcpiPciLinkCrsIrqZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid Resource_type",
   "advice": "A PCI link set failed because the link IRQ resource type is invalid.",
   "label": "KlogAcpiPciLinkIrqResourceInvalid"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to set IRQ for",
   "advice": "An attempt to enabled the link device failed.",
   "label": "KlogAcpiPciLinkFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid link device",
   "advice": "Unable to allocate an IRQ failed because the link device is invalid.",
   "label": "KlogAcpiPciLinkDeviceInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid link context",
   "advice": "Unable to allocate an IRQ failed because the link context was invalid (NULL).",
   "label": "KlogAcpiPciLinkContextNull"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Invalid index",
   "advice": "Support for multiple index IRQ entries per link device is not yet implemented.",
   "label": "KlogAcpiPciLinkMultipleIrqEntries"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Link active IRQ is 0",
   "advice": "Unable to allocate an IRQ failed because the active IRQ is 0, which is wrong.",
   "label": "KlogAcpiPciLinkActiveIrqZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Link isn't initialized",
   "advice": "An attempt to free the IRQ of a link failed because the link was not initialized.",
   "label": "KlogAcpiPciLinkNotInitialized"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating processor object",
   "advice": "An error occurred evaluating the ACPI Processor() object, ACPI CPU control for this CPU broken.",
   "label": "KlogAcpiProcessorFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Evaluating processor _UID",
   "advice": "An error occurred evaluating an ACPI CPU _UID, ACPI CPU control for this CPU is broken.",
   "label": "KlogAcpiProcessorBadUid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid PBLK length",
   "advice": "The Processor Register Block data is not the expected size, ACPI control of this CPU will not occur.",
   "label": "KlogAcpiProcessorPblkBad"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid _PSS data",
   "advice": "Failed to get ACPI performance states from the _PSS contol, buffer was either NULL or not an ACPI package.",
   "label": "KlogAcpiPssFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid BIOS _PSS frequency found for processor",
   "advice": "CPU frequency in MHz as supplied by _PSS control cannot be stored in a 32 bit unsigned integer, overflow error.",
   "label": "KlogAcpiPssFreqTooBig"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "No valid BIOS _PSS frequency found for processor",
   "advice": "One of the CPUs did not have a valid _PSS frequency defined. Cannot fetch _PSS levels for this CPU.",
   "label": "KlogAcpiPssNotFound"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid _PSD data",
   "advice": "The ACPI _PSD control returned a pointer that was NULL or not an ACPI package or did not have 1 item in the package or the item could not be fetched out of the package. P-State dependencies cannot be evaluated, machine may perform sub-optimally.",
   "label": "KlogAcpiPsdBadData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown _PSD:num_entries",
   "advice": "The number of _PSD entries should be 5 but a different count was returned. The P-State dependencies cannot be evaluated, machine may perform sub-optimally.",
   "label": "KlogAcpiPsdBadCount"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unknown _PSD:revision",
   "advice": "The _PSD revision should be 0 but a different version was returned. P-State dependencies cannot be evaluated, machine may perform sub-optimally.",
   "label": "KlogAcpiPsdBadRevision"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid _PSD:coord_type",
   "advice": "The _PSD coordination type was invalid, it should be SW_ALL, SW_ANY or HW_ALL. P-State dependencies cannot be evaluated, machine may perform sub-optimally.",
   "label": "KlogAcpiPsdBadCoordType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_VIDEO",
   "pattern": "Failed to switch the brightness",
   "advice": "The ACPI video brightness for the LCD could not be set because _BCM failed.",
   "label": "KlogAcpiVideoBcmFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_VIDEO",
   "pattern": "Invalid _DOD data in element",
   "advice": "The ACPI _DOD control returned an element that was not an ACPI integer as expected. This element will be ignored, which could lead to reduced functionality.",
   "label": "KlogAcpiVideoDodFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_VIDEO",
   "pattern": "Invalid _DDC data",
   "advice": "The ACPI _DDC control is returning either a NULL buffer pointer or data that is not an ACPI buffer. The Extended Display Identification Data (EDID) structure that represents the display output device could not be fetched. This may affect video output.",
   "label": "KlogAcpiVideoDdcFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_VIDEO",
   "pattern": "Invalid _BCL data",
   "advice": "The ACPI _BCL control is returning either a NULL buffer pointer or data that is not an ACPI package. LCD brightness level queries will not work.",
   "label": "KlogAcpiVideoBclFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Oops, 'acpi_handle' corrupt",
   "advice": "Failed to unbind a device, the ACPI handle was corrupt.",
   "label": "KlogAcpiHandleCorrupt"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Can't use platform_notify",
   "advice": "Cannot add the ACPI platform notifiers, they are already registered. This should not happen.",
   "label": "KlogAcpiPlatformNotify"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:Error in acpi_memory_enable_device",
   "advice": "Adding a hotplug memory device failed because.",
   "label": "KlogAcpiHotPlugAddMemDeviceFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_INFO",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:Disable memory device",
   "advice": "An ACPI notify eject request occurred to disable a memory device.",
   "label": "KlogAcpiHotPlugNotifyDisableOkay"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:Driver Data is NULL",
   "advice": "An ACPI notify eject request failed because the device data is NULL.",
   "label": "KlogAcpiHotPlugNotifyEjectDataNull"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Device doesn't exist",
   "advice": "An ACPI notify eject request failed because the device does not exist.",
   "label": "KlogAcpiHotPlugNotifyEjectDeviceNotExist"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:Cannot enable memory device",
   "advice": "Memory device notify failed because it could not enabled the memory device.",
   "label": "KlogAcpiHotPlugEnableFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:Cannot find driver data",
   "advice": "Memory device notify failed because it could not find the relevant driver data for this device.",
   "label": "KlogAcpiHotPlugDeviceNotify"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:add_memory failed",
   "advice": "Failed to add memory device, add_memory() failed for some reason.",
   "label": "KlogAcpiHotPlugAddMemoryFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "memory_hp:get_device_resources failed",
   "advice": "The devices resources could not be determined from the relevant ACPI _CRS control and so the memory device could not be enabled.",
   "label": "KlogAcpiHotPlugCrsFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Fatal opcode executed",
   "advice": "An ACPI AML fatal opcode was executed and the kernel has trapped this signal. It could be because of faulty control method code.",
   "label": "KlogAcpiFatalOpcodeSignal"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Call to queue_work() failed.",
   "advice": "Failed to queue up AML exec work on CPU 0. This results in ACPI control code not being executed which could lead to unexpected behaviour.",
   "label": "KlogAcpiQueueWorkFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "acpi_os_get_timer() TBD",
   "advice": "Support for the 64 bit ACPI AML timer operand is not implemented, this will be emulated and may affect AML code that relies on accurate timers.",
   "label": "KlogAcpiGetTimerNotImplemented"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "SCI .* allocation failed",
   "advice": "Failed to install an ACPI SCI interrupt handler because the the IRQ allocation failed.",
   "label": "KlogAcpiSciIrqAllocError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "SCI .*ACPI GSI .* not registered",
   "advice": "Failed to install an ACPI SCI interrupt handler because the Global System Interrupt (GSI) is not registered.",
   "label": "KlogAcpiSciGsiError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Cannot map memory that high",
   "advice": "Cannot map an ACPI physical address above the 32 bit 4GB limit, this could lead to broken functionality.",
   "label": "KlogAcpiMap4GbLimit"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "System description tables not found",
   "advice": "The EFI ACPI20 or ACPI RSDP pointers were invalid, so the kernel cannot find any of the ACPI tables.  ACPI support will be disabled.",
   "label": "KlogAcpiEfiRsdpError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Vendor .* System .* Revision .* has a known ACPI BIOS problem",
   "advice": "The kernel has recognised that this particular version of the firmware has known ACPI issues and so ACPI support will be disabled. Reduced functionality will occur.",
   "label": "KlogAcpiBlackListed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to register for device notifications",
   "advice": "The ACPI device notify handlers failed to be installed and so ACPI support with be disabled.",
   "label": "KlogAcpiNotifyHandlerInstallFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to initialize ACPI objects",
   "advice": "The ACPI objects failed to initialize and so ACPI support with be disabled.",
   "label": "KlogAcpiObjectsFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to start the ACPI Interpreter",
   "advice": "The ACPI interpreter failed to start up correctly and so ACPI support with be disabled.",
   "label": "KlogAcpiInterpreterFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to enable ACPI",
   "advice": "The ACPI subsystem failed to be enabled and so ACPI support with be disabled.",
   "label": "KlogAcpiEnableFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to load the System Description Tables",
   "advice": "The ACPI driver was unabled to load the ACPI tables and so ACPI support will be disabled.",
   "label": "KlogAcpiLoadFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to initialize the ACPI Interpreter",
   "advice": "The ACPI interpreter could not be intialized and so ACPI support will be disabled.",
   "label": "KlogAcpiInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Unable to reallocate ACPI tables",
   "advice": "The kernel count not reallocate the ACPI tables into memory from firmware and so ACPI support will be disabled.",
   "label": "KlogAcpiReallocateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "can't evaluate _SEG",
   "advice": "The _SEG ACPI control could not be evaluated. This will stop certain PCI root bridges from being added and enabled on the computer.",
   "label": "KlogAcpiSegFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "can't evaluate _BBN",
   "advice": "The _BBN ACPI control could not be evaluated. This will stop certain PCI root bridges from being added and enabled on the computer.",
   "label": "KlogAcpiSegFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Bus .*:.* not present in PCI namespace",
   "advice": "The bus cound not be found in the PCI namespace. This will stop certain PCI root bridges from being added and enabled on the computer.",
   "label": "KlogAcpiPciScanFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_POWER",
   "pattern": "_DSW execution failed",
   "advice": "The ACPI control _DSW (Device Sleep Wake) failed to execute, this may impact on the ability to enable or disable the wake capabilities of a device in the computer.",
   "label": "KlogAcpiDswFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_POWER",
   "pattern": "_PSW execution failed",
   "advice": "The ACPI control _PSW (Power State Wake) failed to execute, this may impact on the ability to enable or disable the wake capabilities of a device in the computer.",
   "label": "KlogAcpiPswFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_POWER",
   "pattern": "Transition power state",
   "advice": "Failed to power on or shutdown a wakeup device using _PSW or _DSW control methods.",
   "label": "KlogAcpiSuspend"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_EMBEDDED_CONTROLLER",
   "pattern": "Fail in evaluating the _REG object of EC device",
   "advice": "The _REG object for the Embedded Controller Device could not be evaluated, however the kernel will ignore this and try to install the handler for the Embedded Controller.",
   "label": "KlogAcpiEcBadReg"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_DOCK",
   "pattern": "Unable to undock",
   "advice": "An undock event was requested but the machine still seems to be docked.",
   "label": "KlogAcpiDockCannotUndock"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_DOCK",
   "pattern": "Unable to dock",
   "advice": "A dock notify event was handled but the machine still seems to be undocked.",
   "label": "KlogAcpiDockCannotDoct"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_DOCK",
   "pattern": "Unknown dock event",
   "advice": "A dock notify event was handled, but the type of notify event was not recognised.",
   "label": "KlogAcpiDockEvent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_DOCK",
   "pattern": ".* encountered error .*",
   "advice": "An error occurred when trying to add a new dock station device.",
   "label": "KlogAcpiDockAdd"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_BUTTON",
   "pattern": "More than one Lid device found",
   "advice": "Failed to add a Lid device because one already exists.  The kernel does not support more than one Lid device.",
   "label": "KlogAcpiLidMany"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_ACPI_BUTTON",
   "pattern": "Unsupported hid",
   "advice": "The Lid Hardware ID (HID) is one that the kernel does not recognise and so the Lid device was not added to the system. This can explain why the Lid does not work.",
   "label": "KlogAcpiLidBadHid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_CONTAINER",
   "pattern": "device is NULL",
   "advice": "The kernel count not add a container because the device associated with this was NULL, which is unexexpected.",
   "label": "KlogAcpiContainer"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_ACPI_SUSPEND",
   "pattern": "wakeup header does not match",
   "advice": "The ACPI suspend wakeup header did not contain the expected header value so the kernel had to abort the suspend. This can happen if the data is corrupted.",
   "label": "KlogAcpiSuspendHeader"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_ACPI_EVAL",
   "pattern": "not enough elements in _CST",
   "advice": "_CST returned either a NULL buffer or a type that wasn't an ACPI package or less than 2 elements in the package. The kernel could not evaluate the CPU supported C states supported, meaning that the machine will not run optimally.",
   "label": "KlogAcpiCstElements"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_ACPI_EVAL",
   "pattern": "count given by _CST is not valid",
   "advice": "_CST returned an invalid number of elements, the package a different number of C states to the number of C states that _CST reported. The kernel could not evaluate the CPU supported C states supported, meaning that the machine will not run optimally.",
   "label": "KlogAcpiCstCount"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_EVAL",
   "pattern": "No return object",
   "advice": "An ACPI evaluate for a reference returned a buffer of zero length or a NULL buffer pointer.",
   "label": "KlogAcpiEvalReferenceBadBuffer"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_EVAL",
   "pattern": "Expecting a [Package], found type",
   "advice": "An ACPI evaluate for a reference did not return a ACPI package as expected.",
   "label": "KlogAcpiEvalReferenceNotPackage"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_EVAL",
   "pattern": "[Package] has zero elements",
   "advice": "An ACPI evaluate for a reference returned an illeage package of zero elements.",
   "label": "KlogAcpiEvalReferencePackageZeroElements"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_ACPI_EVAL",
   "pattern": "Expecting a [Reference] package element, found type",
   "advice": "An ACPI evaluate for a reference returned contained an element that was not a reference type.",
   "label": "KlogAcpiEvalReferencePackageElementType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_EMBEDDED_CONTROLLER",
   "pattern": "error obtaining _EC",
   "advice": "The ACPI Embedded Controller Offset Query Control Method _EC failed to evaluate. It is either missing or broken and means the kernel cound not add a SMBUS host controller.",
   "label": "KlogAcpiEcFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "host controller is not configured",
   "advice": "The kernel count not issue a SMBUS transaction because the host controller was not configured. See acpi_smbus_transaction()",
   "label": "KlogSmbusHostController"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Error attaching device data",
   "advice": "The kernel could not register a thermal zone because acpi_attach_data() failed for some reason. The machine may not be able to optimally cool itself and may have overheating issues because of this error.",
   "label": "KlogAcpiThermZoneAttachFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _TSS data: freq is zero",
   "advice": "The _TSS has returned a zero fequency setting in one or more of the package elements.",
   "label": "KlogAcpiTssZeroFrequency"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _TSS data",
   "advice": "The _TSS has returned a NULL data pointer or data which isn't an ACPI package.",
   "label": "KlogAcpiTssBadData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Unknown _TSD:num_entries",
   "advice": "The number of entries in the throlling domain information was not 5.",
   "label": "KlogAcpiTsdIllegalNumEntries"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Unknown _TSD:revision",
   "advice": "The expected TSD revision was not 0.",
   "label": "KlogAcpiTsdBadRevision"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "HARDWARE addr space,NOT supported yet",
   "advice": "The CPU does not seem to support the MSR_IA32_THERM_CONTROL MSR.",
   "label": "KlogAcpiUnsupportedThermControlMsr"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Unknown addr space",
   "advice": "Could not read the hardware specific throttling status, the status register space ID was not a system I/O space or a fixed hardware space.",
   "label": "KlogAcpiThrottleStatusBadRead"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _TSD data",
   "advice": "The _TSD has returned data which isn't valid, either a NULL data pointer or data which isn't an ACPI package has been returned.",
   "label": "KlogAcpiTsdBadData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _PTC control register",
   "advice": "The _PTC control register bit widths or bit offsets are incorrect.",
   "label": "KlogAcpiPtcControlRegisterInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _PTC status register",
   "advice": "The _PTC status register bit widths or bit offsets are incorrect.",
   "label": "KlogAcpiPtcStatusRegisterInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _PTC data (status_register)",
   "advice": "The _PTC status register data (element 1 of the package) was either NULL or too small.",
   "label": "KlogAcpiPtcDataStatusRegister"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _PTC data (control_register)",
   "advice": "The _PTC control register data (element 0 of the package) was either NULL or too small.",
   "label": "KlogAcpiPtcDataControlRegister"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Invalid _PTC data",
   "advice": "_PTC did not return a package of two elements, expected a two element package containing bufffers for the control and status register.",
   "label": "KlogAcpiPtcDataBad"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Failed to create sysfs link 'thermal_cooling'",
   "advice": "sysfs_create_link() failed to create the thermal 'thermal_cooling' sysfs entry.",
   "label": "KlogAcpiThermalThermalCoolingSysfs"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Failed to create sysfs link 'device'",
   "advice": "sysfs_create_link() failed to create the thermal 'device' sysfs entry.",
   "label": "KlogAcpiThemalDeviceSysfs"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Setting initial power state",
   "advice": "The call to acpi_bus_update_power() in acpi_fan_add() failed while adding a new fan device.",
   "label": "KlogAcpiFanAddFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_EMBEDDED_CONTROLLER",
   "pattern": "EC.*input buffer is not empty, aborting transaction",
   "advice": "The ACPI Embedded Controller (EC) driver attempted to perform a read or write transaction but had to abort because the EC was still busy and the input buffer was not emptied within 500ms.  Normally this indicates an EC firmware fault.  One can try increasing the delay using the acpi.ec_delay kernel parameter or writing to /sys/module/acpi/parameters/ec_delay - however this generally does not help much of the EC firmware is buggy.",
   "label": "KlogAcpiEcInputBufferIsNotEmpty"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_INFO",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "ENERGY_PERF_BIAS.*Set to 'normal'.* was 'performance'",
   "advice": "This is not exactly a failure but a warning from the kernel. The MSR_IA32_ENERGY_PERF_BIAS was initialized and defaulted to a high performance bias setting. The kernel has detected this and changed it down to a 'normal' bias setting.",
   "label": "KlogEnergyPerfBiasSetToNormal"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "pnp.*can't evaluate _CRS: 12311",
   "advice": "The _CRS object could not be evaluated because an invalid resource type has been returned. This can lead to misconfigured PNP hardware and may render a system unbootable.",
   "label": "KlogPnpCrsInvalidResourceType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "pnp.*can't evaluate _CRS:",
   "advice": "The _CRS object could not be evaluated, the error code is an ACPI error return code (see include/acpi/acexecp.h in the linux source, this is composed of bottom 12 bits of an error number and upper 4 bits of an AE_CODE_* code. Typically, _CRS evaluation errors can lead to misconfigured PNP hardware and may render a system unbootable.",
   "label": "KlogPnpCrsCannotEvaluate"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "dell_wmi:.*Received unknown WMI event",
   "advice": "The Dell WMI driver has received an unknown WMI event. The driver should handle this new event or the firmware is reporting an incorrect and unknown event.",
   "label": "KlogDellWmiReceivedUnknownWMIEvent"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "dell_wmi:.*bad event status 0x",
   "advice": "The Dell WMI driver has received a bad event status. This should be investigated further.",
   "label": "KlogDellWmiBadEventStatus"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "asus_wmi:.*Unknown key.*pressed",
   "advice": "The ASUS WMI driver has received an unknown key event. The driver should handle this new key event or the firmware is reporting an incorrect and unknown event.",
   "label": "KlogAsusWmiUnknownKeypressed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "hp_wmi:.*bad event status 0x",
   "advice": "The HP WMI driver has received a bad event status. This should be investigated further.",
   "label": "KlogHpWmiBadEventStatus"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Failed to create sysfs link 'thermal_cooling'",
   "advice": "sysfs_create_link() failed to create the thermal 'thermal_cooling' sysfs entry.",
   "label": "KlogAcpiThermalThermalCoolingSysfs"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "Failed to create sysfs link 'device'",
   "advice": "sysfs_create_link() failed to create the thermal 'device' sysfs entry.",
   "label": "KlogAcpiThemalDeviceSysfs"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_EMBEDDED_CONTROLLER",
   "pattern": "EC.*input buffer is not empty, aborting transaction",
   "advice": "The ACPI Embedded Controller (EC) driver attempted to perform a read or write transaction but had to abort because the EC was still busy and the input buffer was not emptied within 500ms.  Normally this indicates an EC firmware fault.  One can try increasing the delay using the acpi.ec_delay kernel parameter or writing to /sys/module/acpi/parameters/ec_delay - however this generally does not help much of the EC firmware is buggy.",
   "label": "KlogAcpiEcInputBufferIsNotEmpty"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "pnp.*can't evaluate _CRS: 12311",
   "advice": "The _CRS object could not be evaluated because an invalid resource type has been returned. This can lead to misconfigured PNP hardware and may render a system unbootable.",
   "label": "KlogPnpCrsInvalidResourceType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "pnp.*can't evaluate _CRS:",
   "advice": "The _CRS object could not be evaluated, the error code is an ACPI error return code (see include/acpi/acexecp.h in the linux source, this is composed of bottom 12 bits of an error number and upper 4 bits of an AE_CODE_* code. Typically, _CRS evaluation errors can lead to misconfigured PNP hardware and may render a system unbootable.",
   "label": "KlogPnpCrsCannotEvaluate"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "dell_wmi:.*Received unknown WMI event",
   "advice": "The Dell WMI driver has received an unknown WMI event. The driver should handle this new event or the firmware is reporting an incorrect and unknown event.",
   "label": "KlogDellWmiReceivedUnknownWMIEvent"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "dell_wmi:.*bad event status 0x",
   "advice": "The Dell WMI driver has received a bad event status. This should be investigated further.",
   "label": "KlogDellWmiBadEventStatus"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "asus_wmi:.*Unknown key.*pressed",
   "advice": "The ASUS WMI driver has received an unknown key event. The driver should handle this new key event or the firmware is reporting an incorrect and unknown event.",
   "label": "KlogAsusWmiUnknownKeypressed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "hp_wmi:.*bad event status 0x",
   "advice": "The HP WMI driver has received a bad event status. This should be investigated further.",
   "label": "KlogHpWmiBadEventStatus"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "hp_wmi:.*Unknown response received",
   "advice": "The HP WMI driver has received a return object that was not of type ACPI_BUFFER. The driver needs to be updated to handle this new return type or there is a bug in the WMI mechanism on this machine.",
   "label": "KlogHpWmiUnknownResponseReceived"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "hp_wmi:.*Unknown buffer length",
   "advice": "The HP WMI driver has received a return buffer that was not the expected size of 8 or 16 bytes. This is probably a bug in the WMI mechanism on this machine.",
   "label": "KlogHpWmiUnknownBufferLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "hp_wmi:.*Unknown key code - 0x",
   "advice": "The HP WMI driver has received a key code that it does not recognise. The driver needs to be updated to handle this new key code.",
   "label": "KlogHpWmiUnknownKeyCode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "hp_wmi:.*Unknown event_id",
   "advice": "The HP WMI driver has received an event ID that it does not recognise. The driver needs to be updated to handle this new event ID.",
   "label": "KlogHpWmiUnknownEventId"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_WMI",
   "pattern": "msi_wmi:.*Unknown key pressed",
   "advice": "The MSI WMI driver has received a key code that it does not recognise. The driver needs to be updated to handle this new key code.",
   "label": "KlogMsiWmiUnknownKeyPressed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI.*Handling Garbled _PRT entry",
   "advice": "BIOS has a garbled _PRT entry; source_name and source_index swapped.",
   "label": "KlogAcpiHandlingGarbledPrtEntry"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "Invalid _PCT data",
   "advice": "The ACPI _PCT data is invalid.",
   "label": "KlogInvalidPctData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI Error.*ACPI path has too many parent prefixes",
   "advice": "A path to an ACPI obejct has too many ^ parent prefixes and references passed the top of the root node. Please check AML for all ^ prefixed ACPI path names.",
   "label": "KlogAcpiPathTooManyParentPrefixes"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_RSDP",
   "pattern": "A valid RSDP was not found",
   "advice": "An ACPI compatible system must provide an RSDP (Root System Description Pointer). This structure provides the physical address of the RSDT and XSDT. Since this could not be found, the ACPI driver has had to disable ACPI support.",
   "label": "KlogAcpiValidRsdpNotFound"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_MUTEX",
   "pattern": "ACPI Error.*Cannot release Mutex",
   "advice": "Attempted to release of a Mutex that was not previous acquired. This needs fixing as it could lead to race conditions when operating on a resource that needs to be proteced by a Mutex.",
   "label": "KlogAcpiCannotReleaseMutex"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_EVENT",
   "pattern": "ACPI Error.*Could not disable .* event",
   "advice": "",
   "label": "KlogAcpiCouldNotDisableEvent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_EVENT",
   "pattern": "ACPI Error.*Could not enable .* event",
   "advice": "",
   "label": "KlogAcpiCouldNotEnableEvent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_NAMESPACE_LOOKUP",
   "pattern": "ACPI Error.*Namespace lookup failure, AE_ALREADY_EXISTS",
   "advice": "",
   "label": "KlogAcpiNamespaceLookupFailure"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_BUFFER_OVERFLOW",
   "pattern": "ACPI Error.*_SB_._OSC.*AE_AML_BUFFER_LIMIT",
   "advice": "Section 6.2.10.2 of V4.0a of the ACPI specification states that the _OSC Method should be passed an 8 byte buffer of 2 x 32 DWORDs, however it appears that the method is possibly trying to access data outside this buffer. This is a bug in the _OSC method.",
   "label": "KlogAcpiSbOscAeAmlBufferLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI",
   "pattern": ".*pci.*ACPI _OSC request failed.*returned control mask",
   "advice": "The _OSC method evaluation failed, which will result in disabling PCIe functionality, for example, the Linux kernel has to disable Active State Power Management (ASPM) which means that PCIe power management is not optimally configured.",
   "label": "KlogPciAcpiOscRequestFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_OSC invalid UUID",
   "advice": "The _OSC method indicates it has been passed an invalid UUID, see section 6.2.10 _OSC (Operating System Capabilities) of the ACPI specification for more details.  Note that it has been observed on some systems that this error is returned because the _OSC has evaluated incorrectly and it returns with an incorrect error setting the OSC invalid UUID error bit.",
   "label": "KlogOscInvalidUuid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_OSC invalid revision",
   "advice": "The _OSC method indicates it has been passed an invalid revision number, see section 6.2.10 _OSC (Operating System Capabilities) of the ACPI specification for more details.  Note that the revision level is specific to the given UUID.",
   "label": "KlogOscInvalidRevision"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_OSC request failed",
   "advice": "The _OSC method evaluation failed for some unknown reason. This could be that the data passed to it was incorrect or that the method itself is broken. See section 6.2.10 _OSC (Operating System Capabilities) of the ACPI specification for more details.",
   "label": "KlogOscRequestFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "_OSC request failed",
   "advice": "The _OSC method evaluation failed for some unknown reason. This could be that the data passed to it was incorrect or that the method itself is broken. See section 6.2.10 _OSC (Operating System Capabilities) of the ACPI specification for more details.",
   "label": "KlogOscRequestFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_BUFFER_OVERFLOW",
   "pattern": "ACPI Error.*Field.*exceeds Buffer",
   "advice": "The field exceeds the allocated buffer size. This can lead to unexpected results when fetching data outside this region.",
   "label": "KlogAcpiFieldexceedsBuffer"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_IO_PORT",
   "pattern": "ACPI Error.*Illegal I\/O port address\/length above 64K",
   "advice": "A port address or length has exceeded the maximum allowed 64K address limit. This will lead to unpredicable errors.",
   "label": "KlogAcpiIllegalIOAbove64K"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Error.*Incorrect return type",
   "advice": "An ACPI Method has returned an unexpected and incorrect return type.",
   "label": "KlogAcpiIncorrectReturnType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Error.*Needed .*\\[Buffer\/String\/Package\\], found \\[Integer\\]",
   "advice": "An ACPI Method has returned an Integer type when a Buffer, String or Package was expected.",
   "label": "KlogAcpiNeededBufferOrStringOrPackage"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Error.*Needed .*\\[Reference\\], found \\[Device\\]",
   "advice": "An ACPI Method has returned an Device type when a Reference type was expected.",
   "label": "KlogAcpiNeededReference"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_NO_HANDLER",
   "pattern": "ACPI Error.*No handler for Region",
   "advice": "",
   "label": "KlogAcpiNoHandlerForRegion"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_NO_HANDLER",
   "pattern": "ACPI Error.*Region .* has no handler",
   "advice": "",
   "label": "KlogAcpiRegionHasNoHandler"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Error.*Missing expected return value",
   "advice": "The ACPI Method did not return a value and was expected too. This is a bug and needs fixing.",
   "label": "KlogAcpiMissingExpectedReturnValue"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "Package List length.*larger than.*truncated",
   "advice": "A Method has returned a Package List that was larger than expected.",
   "label": "KlogAcpiPackageListLargerThanExpected"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Error.*Result stack is empty!",
   "advice": "",
   "label": "KlogAcpiResultStackEmpty"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_AML_OPCODE",
   "pattern": "ACPI Error.*Found unknown opcode",
   "advice": "An illegal AML opcode has been found and is ignored. This indicates either badly compiled code or opcode corruption in the DSDT or SSDT tables or a bug in the ACPI execution engine. Recommend disassembing using iasl to find any offending code.",
   "label": "KlogAcpiFoundUnknownOpcode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_AML_OPCODE",
   "pattern": "ACPI Warning.*Detected an unsupported executable opcode",
   "advice": "An illegal AML opcode has been found and is ignored. This indicates either badly compiled code or opcode corruption in the DSDT or SSDT tables or a bug in the ACPI execution engine. Recommend disassembing using iasl to find any offending code.",
   "label": "KlogAcpiDetectedUnsupportedOpCode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "bios32_service.*not present",
   "advice": "The BIOS has found a BIOS32 Service Directory but the BIOS has returned error 0x80 on calling the service, which indicates that the requested service has not been implemented in the firmware.",
   "label": "KlogBios32ServiceNotPresent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "bios32_service.*BIOS bug",
   "advice": "The BIOS has found a BIOS32 Service Directory but the BIOS has returned an error on calling the service, which is unexpected and usually means the firmware is broken.",
   "label": "KlogBios32ServiceBiosBug"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS_IRQ",
   "pattern": "PCI: Error.*when fetching IRQ routing table",
   "advice": "The BIOS has been interrogated for the PCI IRQ routing table but the BIOS returned an error.",
   "label": "KlogPciFetchingIRQRoutingTable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Denied AML access to port",
   "advice": "AML code was accessing an I/O port that was banned from accesses. Ports 0x20-0x21 (PIC0), 0xa0-0xa1 (PIC1), 0x4d0-0x4d1 (ELCR) are always banned. For _OSI() greater or equal to 'Windows 2001' (Windows XP) ports 0x00-0x0f (DMA), 0x40-0x43 (PIT1), 0x48-0x4b (PIT2), 0x70-0x71 (RTC), 0x81-0x83 (DMA1), 0x87 (DMA1L), 0x89-0x8b (DMA2), 0x8f (DMA2L), 0x90-0x91 (ARBC), 0x93-0x94 (SETUP), 0x96-0x97 (POS), 0xc0-0xdf (ISA DMA) and 0xcf8-0xcff (PCI config) are banned.  Since the AML code has been banned from accessing these ports you will get undefined behaviour and the AML code should be fixed.",
   "label": "KlogAcpiDeniedAmlAccessToPort"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "Method parse\/execution failed.*AE_AML_NO_RETURN_VALUE",
   "advice": "The ACPI Method was expected to return a value and did not.",
   "label": "KlogAcpiMethodNoReturnValue"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "Method parse/execution failed",
   "advice": "The ACPI driver encounter a parse or execution error on some ACPI AML code. This is unexepcted and normally indicates that there is a bug in the compiled AML code.  It could be a programming fault or an AML compiler issue.  See acpi_ps_parse_aml().",
   "label": "KlogAcpiParseExecAmlFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_ALREADY_EXISTS",
   "advice": "",
   "label": "KlogAcpiObjectAlreadyExists"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_INVALID_TABLE_LENGTH",
   "advice": "The ACPI Method returned a table of the incorrect length. This can lead to unexepected results.",
   "label": "KlogAcpiInvalidTableLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_AML_BUFFER_LIMIT",
   "advice": "Method failed: ResourceSourceIndex is present but ResourceSource is not.",
   "label": "KlogAcpiBufferLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_NOT_EXIST",
   "advice": "",
   "label": "KlogAcpiObjectDoesNotExist"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_NOT_FOUND",
   "advice": "",
   "label": "KlogAcpiObjectNotFound"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_LIMIT",
   "advice": "",
   "label": "KlogAcpiExecLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_AML_OPERAND_TYPE",
   "advice": "",
   "label": "KlogAcpiOperandType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_TIME",
   "advice": "",
   "label": "KlogAcpiTimeOut"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_AML_PACKAGE_LIMIT",
   "advice": "",
   "label": "KlogAcpiPackageLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_OWNER_ID_LIMIT",
   "advice": "Method failed to allocate owner ID.",
   "label": "KlogAcpiOwnerIdLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_AML_MUTEX_NOT_ACQUIRED",
   "advice": "A Mutex acquire failed, which could possibly indicate that it was previously acquired and not released, or a race has occurred. Some AML code fails to miss Mutex acquire failures, so it is a good idea to verify all Mutex Acquires using the syntaxcheck test.",
   "label": "KlogAcpiMutexNotAcquired"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI Error.*SMBus or IPMI write requires Buffer of",
   "advice": "An incorrect SMBus or IPMI write buffer size was used.",
   "label": "KlogAcpiIncorrectWriteBufferSize"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_EVAL",
   "pattern": "ACPI (Warning|Error).*Evaluating .* failed",
   "advice": "Executing the ACPI Method leaded in an execution failure. This needs investigating.",
   "label": "KlogAcpiEvaluationFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "ACPI Warning.*Optional field.*has zero address or length",
   "advice": "An ACPI table contains Generic Address Structure that has an address that is incorrectly set to zero, or a zero length. This needs to be fixed. ",
   "label": "KlogAcpiOptionalFieldZeroAddressOrLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "ACPI (Warning|Error).*two DSDT tables",
   "advice": "The FADT table contains a mismatch between the 32 bit pointer (DSDT) and 64 bit pointer (X_DSDT) pointer to the FACS table.  Section 5.2.9 of version 4.0a of the ACPI specification states that X_DSDT should be zero if DSDT is defined, or DSDT should be zero if X_DSDT is zero. With two different pointers defined, the kernel has to make a choice, and opts for the 32 bit pointer. Because these pointers are different, it suggests either one of them is incorrect, or different 32 bit and 64 bit DSDT tables are present in your system, which is NOT complaint with the ACPI specification.  The kernel has to make a choice and opts for the 32 bit DSDT.",
   "label": "KlogAcpiTwoDsdt"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "ACPI (Warning|Error).*two FACS tables",
   "advice": "The FADT table contains a mismatch between the 32 bit pointer (FIRMWARE_CTRL) and 64 bit pointer (X_FIRMWARE_CTRL) pointer to the FACS table.  Section 5.2.9 of version 4.0a of the ACPI specification states that X_FIRMWARE_CTRL should be zero if FIRMWARE_CTRL is defined, or FIRMWARE_CTRL should be zero if X_FIRMWARE_CTRL is zero. With two different pointers defined, the kernel has to make a choice, and opts for the 32 bit pointer. Because these pointers are different, it suggests either one of them is incorrect, or different 32 bit and 64 bit FACS tables are present in your system, which is NOT complaint with the ACPI specification.  The kernel has to make a choice and opts for the 32 bit FIRMWARE_CTRL.",
   "label": "KlogAcpiTwoFacs"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "32/64X address mismatch in.*, using 32",
   "advice": "The FADT table contains a mismatch between a 32 bit pointer and a 64 bit Generic Address pointer. Because these pointers are different, it suggests either one of them is incorrect.  If a non-null 32 bit pointer exists, then the kernel will opt for this in preference to the 64 bit pointer even though this is not in accordance to the ACPI specification.",
   "label": "KlogAcpi32Bit64BitAddressMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "ACPI (Warning|Error).*32\/64.*(length|address) mismatch in.*tbfadt",
   "advice": "The FADT table contains Generic Address Structure that has a mismatch between the 32 bit and 64 bit versions of an address. This should be fixed so there are no mismatches. ",
   "label": "KlogAcpi32Bit64BitAddressMismatchInFadt"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "ACPI (Warning|Error).*32\/64.*(length|address) mismatch in",
   "advice": "A table contains Generic Address Structure that has a mismatch between the 32 bit and 64 bit versions of an address. This should be fixed so there are no mismatches. ",
   "label": "KlogAcpi32Bit64BitAddressMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Warning.*Return Package type mismatch",
   "advice": "ACPI AML interpreter executed a Method that returned a package with incorrectly typed data. The offending method needs to be fixed.",
   "label": "KlogAcpiReturnPackageTypeMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Warning.*Return Package has no elements",
   "advice": "ACPI AML interpreter executed a Method that returned a package with no elements inside it. This is most probably a bug in the Method and needs to be fixed.",
   "label": "KlogAcpiReturnPackageZeroElements"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Warning.*Return Package is too small",
   "advice": "ACPI AML interpreter executed a Method that returned a package with too few elements inside it. This is most probably a bug in the Method and needs to be fixed.",
   "label": "KlogAcpiReturnPackageTooSmall"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_TABLE_CHECKSUM",
   "pattern": "ACPI Warning.*Incorrect checksum in table",
   "advice": "The ACPI table listed above has an incorrect checksum, this could be a BIOS bug or due to table corruption.",
   "label": "KlogAcpiIncorrectTableChecksum"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Warning.*_BQC returned an invalid level",
   "advice": "Method _BQC (Brightness Query Current) returned an invalid display brightness level.",
   "label": "KlogAcpiBqcReturnedInvalidLevel"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI Warning.*Could not enable fixed event",
   "advice": "",
   "label": "KlogAcpiCannotEnableFixedEvent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Warning.*Return type mismatch",
   "advice": "The ACPI Method returned an incorrect type, this should be fixed.",
   "label": "KlogAcpiReturnTypeMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARAMETER",
   "pattern": "ACPI Warning.*Parameter count mismatch",
   "advice": "The ACPI Method was executing with a different number of parameters than the Method expected. This should be fixed.",
   "label": "KlogAcpiParameterCountMistmatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARAMETER",
   "pattern": "ACPI Warning.*Insufficient arguments",
   "advice": "The ACPI Method has not enough arguments as expected. This should be fixed.",
   "label": "KlogAcpiInsufficientArguments"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PACKAGE",
   "pattern": "ACPI Warning.*Package has no elements",
   "advice": "The ACPI Method returned a package with no elements in it, and some were exepected.This should be fixed.",
   "label": "KlogAcpiPackageHasNoElements"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "ACPI Warning.*Converted Buffer to expected String",
   "advice": "Method returned a Buffer type instead of a String type and ACPI driver automatically converted it to a String.  It is worth fixing this in the DSDT or SSDT even if the kernel fixes it at run time.",
   "label": "KlogAcpiConvertedBufferToString"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PACKAGE",
   "pattern": "ACPI Warning.*Return Package type mistmatch at index",
   "advice": "The ACPI Method returned a package that contained data of the incorrect data type. This data type needs fixing.",
   "label": "KlogAcpiReturnPackageTypeMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BAD_LENGTH",
   "pattern": "ACPI Warning.*Invalid length for.*fadt",
   "advice": "This item in the FADT is the incorrect length. Should be corrected.",
   "label": "KlogAcpiFadtInvalidLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_THROTTLING",
   "pattern": "ACPI Warning.*Invalid throttling state",
   "advice": "",
   "label": "KlogAcpiInvalidThrottlingState"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI Warning",
   "advice": "ACPI AML intepreter has found some non-conforming AML code. This should be investigated and fixed.",
   "label": "KlogAcpiBadAmlCode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_APIC",
   "pattern": "ACPI.*BIOS bug: multiple APIC\/MADT found, using",
   "advice": "The kernel has detected more than one ACPI Multiple APIC Description Table (MADT) (these tables have the \"APIC\" signature). There should only be one MADT and the kernel will by default select the first one. However, one can override this and select the Nth MADT using acpi_apic_instance=N.",
   "label": "KlogAcpiMultipleApicMadtFound"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "\\[Firmware Bug\\]: ACPI.*Invalid physical address in GAR",
   "advice": "ACPI Generic Address is invalid",
   "label": "KlogAcpiInvalidPhysicalAddress"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS_AMD_POWERNOW",
   "pattern": "\\[Firmware Bug\\]: powernow-k8.*(No PSB or ACPI _PSS objects|No compatible ACPI _PSS|Your BIOS does not provide ACPI _PSS objects)",
   "advice": "The _PSS object (Performance Supported States) is an optional object that indicates the number of supported processor performance states. The powernow-k8 driver source states: If you see this message, complain to BIOS manufacturer. If he tells you \"we do not support Linux\" or some similar nonsense, remember that Windows 2000 uses the same legacy mechanism that the old Linux PSB driver uses. Tell them it is broken with Windows 2000. The reference to the AMD documentation is chapter 9 in the BIOS and Kernel Developer's Guide, which is available on www.amd.com.",
   "label": "KlogAcpiAmdK8ExpectedPssObjects"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS_AMD_POWERNOW",
   "pattern": "\\[Firmware Bug\\]: powernow-k8.*Try again with latest",
   "advice": "",
   "label": "KlogAcpiTryNewAmdFirmware"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "\\[Firmware Bug\\]: ACPI.*Invalid bit width in GAR",
   "advice": "ACPI Generic Address width must be 8, 16, 32 or 64",
   "label": "KlogAcpiGarInvalidBitWidth"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "\\[Firmware Bug\\]: ACPI.*Invalid address space type in GAR",
   "advice": "ACPI Generic Address space type must be system memory or system IO space.",
   "label": "KlogAcpiGarInvalidAddressType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_BAD_ADDRESS",
   "pattern": "\\[Firmware Bug\\]: ACPI.*no secondary bus range in _CRS",
   "advice": "_CRS Method should return a secondary bus address for the status\/command port. The kernel is having to guess this based on the _BBN or assume it's 0x00-0xff.",
   "label": "KlogAcpiCrsSecondaryBusRangeMissing"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]: ACPI.*Invalid BIOS _PSS frequency",
   "advice": "_PSS (Performance Supported States) package has an incorrectly define core frequency (first DWORD entry in the _PSS package).",
   "label": "KlogAcpiInvalidPssFrequency"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BRIGHTNESS",
   "pattern": "\\[Firmware Bug\\]: ACPI.*No _BQC method",
   "advice": "_BQC (Brightness Query Current level) seems to be missing. This method returns the current brightness level of a built-in display output device.",
   "label": "KlogAcpiMissingBqc"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BRIGHTNESS",
   "pattern": "\\[Firmware Bug\\]: ACPI.*brightness control misses _BQC function",
   "advice": "_BQC (Brightness Query Current level) seems to be missing. This method returns the current brightness level of a built-in display output device.",
   "label": "KlogAcpiMissingBqc"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]: BIOS needs update for CPU frequency support",
   "advice": "Having _PPC but missing frequencies (_PSS, _PCT) is a good hint that the BIOS is older than the CPU and does not know the CPU frequencies.",
   "label": "KlogAcpiMissingPssPct"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]: ERST.*ERST table is invalid",
   "advice": "The Error Record Serialization Table (ERST) seems to be invalid. This normally indicates that the ERST table header size is too small, or the table size (excluding header) is not a multiple of the ERST entries.",
   "label": "KlogAcpiErstInvalid"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "\\[Firmware Bug\\]:.*Invalid critical threshold",
   "advice": "ACPI _CRT (Critical Trip Point) is returning a threshold lower than zero degrees Celsius which is clearly incorrect.",
   "label": "KlogAcpiCrtInvalidThreshold"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_THERMAL",
   "pattern": "\\[Firmware Bug\\]:.*No valid trip found",
   "advice": "No valid ACPI _CRT (Critical Trip Point) was found.",
   "label": "KlogAcpiNoValidCrt"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_BRIGHTNESS",
   "pattern": "\\[Firmware Bug\\]:.*_BCQ is used instead of _BQC",
   "advice": "ACPI Method _BCQ was defined (typo) instead of _BQC - this should be fixed.however the kernel has detected this and is working around this typo.",
   "label": "KlogAcpiBcqInsteadOfBqc"
  }, 
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "MPTABLE: bad signature",
   "advice": "The MultiProcessor table has an incorrect signature, it should be PCMP. The kernel cannot trust the table and has disabled SMP support.",
   "label": "KlogBiosMptableBadSignature"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "MPTABLE: checksum error",
   "advice": "The MultiProcessor table has an incorrect checksum. The kernel cannot trust the table and has disabled SMP support.",
   "label": "KlogBiosMptableChecksumError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "MPTABLE: bad table version",
   "advice": "The MultiProcessor table has an incorrect version. It should be 0x01 or 0x04 (for versions 1.1 and 1.4 respectively). The kernel cannot trust the table and has disabled SMP support.",
   "label": "KlogBiosMptableBadVersion"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "MPTABLE: null local APIC address",
   "advice": "The MultiProcessor table contains a NULL Local APIC address but the Local APIC address must be defined. The kernel has disabled SMP support.",
   "label": "KlogBiosMptableNullLapicAddress"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "MPTABLE: no processors registered",
   "advice": "The MultiProcessor table contains no Processor Entry Fields, and hence there are no CPUs defined. The kernel has no option but to disable SMP support.",
   "label": "KlogBiosMptableNoProcessors"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "BIOS bug.*no explicit IRQ entries.*using default mptable",
   "advice": "The MultiProcessor table contains no IRQ Entry Fields, and hence there are no IRQs defined. The table is broken and should be fixed. The kernel will set up the low 16 IO-APIC pins to the ISA defaults in the hope the machine may work.",
   "label": "KlogBiosMptableNoIRQentries"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS_IRQ",
   "pattern": "BIOS bug.*timer not connected to IO-APIC",
   "advice": "The BIOS is reporting the ExtINTA I/O APIC input from the cascaded 8259A as the timer interrupt input.  The kernel has detected just one pin, so it has to check the timer directly and through the 8259A because of the broken BIOS reporting.",
   "label": "KlogBiosTimerNotConnectedtoIoApic"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS_IRQ",
   "pattern": "BIOS bug,.*IO-APIC.*ID is.*in the MPC table.*",
   "advice": "The IO-APIC id in the MPC table is wrong and the kernel has detected this and attempted to fix it. The MPC table in the firmware needs to be fixed.",
   "label": "KlogBiosIoApicInMpcTable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS_IRQ",
   "pattern": "BIOS bug,.*IO-APIC.*ID is already used!",
   "advice": "The IO-APIC id has been defined more than once in the MPC table, which is a firmware bug and should be fixed. The kernel has detected this and skopped this duplication to avoid stuck on smp_invalidate_needed IPI wait' messages.",
   "label": "KlogBiosIoApicIdAlreadyUsed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "WARNING.*BIOS bug.*CPU MTRRs don't cover all of memory, losing",
   "advice": "The Memory Type Range Registers (MTRRs) which define memory caching policy are misconfigued by the BIOS and don't appear to cover all available physical memory. The kernel has detected this and has reduced the amount of memory available to be safe. Either check that the BIOS memory caching options are set correctly or contact your BIOS vendor to get this fixed.",
   "label": "KlogBiosCpuMtrrMisconfigured"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*no more MTRRs available",
   "advice": "A device driver has tried to allocate a Memory Type Range Register (MTRR) to optimially configure a caching policy on a memory region but there are no more free MTRRs available.  Generally the firmware should allow for one or two free MTRRs for drivers to allocate.  The system will have a sub-optimally configured memory region and this may severely impact on performance.",
   "label": "KlogBiosNoMoreMtrrsAvailable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern":  "[drm].*MTRR allocation failed.*Graphics performance may suffer",
   "advice": "The DRM driver has tried to allocate a Memory Type Range Register (MTRR) but there are no more free MTRRs available. The system will have a sub-optimally configured graphics memory region and this may severely impact on graphics rendering throughput and performance.  The firmware should allow for one or two free MTRRs, but it hasn't, which is probably a firmware bug.",
   "label": "KlogBiosMtrrAllocationFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*your BIOS has configured an incorrect mask, fixing it",
   "advice": "The Memory Type Range Registers (MTRRs) which define memory caching policy are misconfigued by the BIOS. In this case, the mask is incorrectly set and the kernel has detected this and worked around the firmware bug.",
   "label": "KlogBiosMtrrIncorrectMask"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*your CPUs had inconsistent fixed MTRR settings",
   "advice": "The fixed Memory Type Range Registers (MTRRs) which define memory caching policy are not consistent across all CPUs which is a firmware bug. The kernel has worked around this bug, but it may be worth getting the BIOS vendor to fix this.",
   "label": "KlogBiosMtrrsInconsistentAcrossCPUs"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*your CPUs had inconsistent variable MTRR settings",
   "advice": "The variable Memory Type Range Registers (MTRRs) which define memory caching policy are not consistent across all CPUs which is a firmware bug. The kernel has worked around this bug, but it may be worth getting the BIOS vendor to fix this.",
   "label": "KlogBiosMtrrsInconsistentAcrossCPUs"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*your CPUs had inconsistent MTRRdefType settings",
   "advice": "The Memory Type Range Registers (MTRRs) which define memory caching policy do not have a MTRRdefType consistently set across all CPUs which is a firmware bug. The kernel has worked around this bug, but it may be worth getting the BIOS vendor to fix this.",
   "label": "KlogBiosMtrrDefTypeIncosistent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*base.*is not 4 MiB aligned",
   "advice": "The Memory Type Range Registers (MTRRs) for Intel PPro CPUs with stepping < 8 must be 4 MiB aligned and not touch 0x70000000 -> 0x7003FFFF. This BIOS misconfiguration and should be fixed.",
   "label": "KlogBiosMtrrNot4MbAligned"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITIICAL",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*writable mtrr between 0x70000000 and 0x7003FFFF may hang the CPU",
   "advice": "The Memory Type Range Registers (MTRRs) for Intel PPro CPUs with stepping < 8 must not touch region 0x70000000 -> 0x7003FFFF. This BIOS misconfiguration may hang the CPU and should be fixed.",
   "label": "KlogBiosMtrrMayHangCPU"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "mtrr:.*base.*is not aligned on a size.*boundary",
   "advice": "The Memory Type Range Registers (MTRRs) must be correctly aligned. This BIOS misconfiguration and should be fixed.",
   "label": "KlogBiosMtrrNotAlignedCorrectly"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": ".*defines _DOD but not _DOS",
   "advice": "ACPI Method _DOD (Enumerate all devices attached to display adapter) is defined but we should also have _DOS (Enable\/Disable output switching) defined but it's been omitted. This can cause display switching issues.",
   "label": "KlogAcpiDodWithNoDos"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "WARNING:.*bogus zero IO-APIC address found in MPTABLE",
   "advice": "An IO-APIC address of zero has been found in the MPTABLE and is thus treated as misconfigured or bogus. I/O APIC support has been disabled. This is considered a firmware bug and the MPTABLE needs to be fixed.",
   "label": "KlogAcpiBogusIoApicInMptable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "WARNING:.*Bogus.*APIC address found in table",
   "advice": "An IO-APIC address of zero has been found in the MPTABLE and is thus treated as misconfigured or bogus. I/O APIC support has been disabled. This is considered a firmware bug and the MPTABLE needs to be fixed.",
   "label": "KlogAcpiBogusIoApicInMptable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]:.*Duplicate ACPI video bus",
   "advice": "Try video module parameter video.allow_duplicates=1 if the current driver does't work.",
   "label": "KlogAcpiDuplicateAcpiVideoBus"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI_PCI_EXPRESS",
   "pattern": "\\[Firmware Bug\\]:.*PCI.*MMCONFIG.*not reserved in ACPI motherboard resources",
   "advice": "It appears that PCI config space has been configured for a specific device but does not appear to be reserved by the ACPI motherboard resources.",
   "label": "KlogAcpiMmconfigNotReserved"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]: PCI.*not reserved in ACPI motherboard resources",
   "advice": "PCI firmware bug. Please see the kernel log for more details.",
   "label": "KlogPciNotReserved"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_INFO",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]:.*_OSI.*Linux.*ignored",
   "advice": "This is not exactly a failure mode but a warning from the kernel. The _OSI() method has implemented a match to the 'Linux' query in the DSDT and this is redundant because the ACPI driver matches onto the Windows _OSI strings by default.",
   "label": "KlogAcpiOsiLinuxIgnored"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]: ACPI:",
   "advice": "ACPI driver has detected an ACPI bug. This generally points to a bug in an ACPI table. Examine the kernel log for more details.",
   "label": "KlogAcpiFirmwareError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "\\[Firmware Bug\\]:.*",
   "advice": "The kernel has detected a Firmware bug in the BIOS or ACPI which needs investigating and fixing.",
   "label": "KlogAcpiFirmwareError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_BIOS",
   "pattern": "PCI.*BIOS Bug:",
   "advice": "",
   "label": "KlogBiosBug"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_NAMESPACE_LOOKUP",
   "pattern": "ACPI Error.*Namespace lookup failure, AE_NOT_FOUND",
   "advice": "The kernel has detected an error trying to execute an Method and it cannot find an object. This is indicates a bug in the DSDT or SSDT AML code.",
   "label": "KlogAcpiNamespaceLookupFailure"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "ACPI Error.+psparse",
   "advice": "The ACPI engine has failed to execute some AML. The error message above lists the method that caused this error.",
   "label": "KlogAcpiParseOrExecFailure"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI",
   "pattern": "ACPI Error",
   "advice": "The kernel has most probably detected an error while executing ACPI AML. The error lists the ACPI driver module and the line number where the bug has been caught and the method that caused the error.",
   "label": "KlogAcpiExecFailure"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "No object was returned from",
   "advice": "The ACPI interpreter was requested to evaluate an ACPI namespace object and was expecting an ACPI object to be returned, but nothing was returned.  This appears to be an ACPI AML bug.",
   "label": "KlogAcpiEvalObjNoObjReturned"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "Method execution failed",
   "advice": "Execution of an ACPI AML method failed. This is normally a bug in the ACPI AML code",
   "label": "KlogAcpiExecFailure"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "\\*\\*\\* Error.*Method execution failed.*AE_AML_METHOD_LIMIT",
   "advice": "ACPI method reached maximum reentrancy limit of 255 - infinite recursion in AML in DSTD or SSDT",
   "label": "KlogAcpiRecursionTooDeep"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_ACPI_PARSE_EXEC_FAIL",
   "pattern": "\\*\\*\\* Error.*Method reached maximum reentrancy limit",
   "advice": "ACPI method has reached reentrancy limit, this is a recursion bug in the AML.",
   "label": "KlogAcpiRecursionTooDeep"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_ACPI_METHOD_RETURN",
   "pattern": "Return object type is incorrect",
   "advice": "Return object type is not the correct type, this is an AML error in the DSDT or SSDT. See also acpi_ut_evaluate_object().",
   "label": "KlogAcpiReturnObjectTypeIncorrect"
  } 
 ], 
 "pm_error_warning_patterns":
 [
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Failed to prepare device",
   "advice": "dpm_prepare() failed to prepare all non-sys devices for a system PM transition. The device should be listed in the error message.",
   "label": "PmFailedToPrepareDevice"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Some devices failed to power down",
   "advice": "dpm_suspend_noirq failed because some devices did not power down ",
   "label": "PmDevicesFailedToPowerDown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Some system devices failed to power down",
   "advice": "sysdev_suspend failed because some system devices did not power down.",
   "label": "PmSystemDevicesFailedToPowerDown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Error",
   "advice": "",
   "label": "PmError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_NONE",
   "pattern": "PM: Some devices failed to power down",
   "advice": "",
   "label": "PmDevicesFailedToPowerDown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Restore failed, recovering",
   "advice": "A resume from hibernate failed when calling hibernation_restore()",
   "label": "PmResumeFromHibernateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Resume from disk failed",
   "advice": "",
   "label": "PmResumeFromDiskFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Not enough free memory",
   "advice": "There was not enough physical memory to be able to generate a hibernation image before dumping it to disc.",
   "label": "PmNotEnoughFreeMemory"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Memory allocation failed",
   "advice": "swusp_alloc() failed trying to allocate highmem and failing that non-highmem pages for the suspend image. There is probably just not enough free physcial memory available.",
   "label": "PmMemoryAllocationFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Image mismatch",
   "advice": "Mismatch in kernel version, system type, kernel release version or machine id between suspended kernel and resumed kernel.",
   "label": "PmKernelMismatch"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Some devices failed to power down",
   "advice": "",
   "label": "PmDevicesFailedToPowerDown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Some devices failed to suspend",
   "advice": "",
   "label": "PmDevicesFailedToSuspend"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: can't read",
   "advice": "Testing suspend cannot read RTC",
   "label": "PmCannotReadRealTimeClock"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: can't set",
   "advice": "Testing suspend cannot set RTC",
   "label": "PmCannotSetRealTimeClock"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: suspend test failed, error",
   "advice": "",
   "label": "PmSuspendTestFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: can't test ",
   "advice": "",
   "label": "PmCannotTest"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: no wakealarm-capable RTC driver is ready",
   "advice": "",
   "label": "PmNoWakeAlarmRealTimeClock"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Adding page to bio failed at",
   "advice": "An attempt to write the hibernate image to disk failed because a write BIO operation failed. This is usually a result of some physical hardware problem.",
   "label": "PmPhysicalDiskWriteError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Swap header not found",
   "advice": "An attempt to write a hibernate image to disk failed because a valid swap device header could not be found. Make sure there is a formatted swap device on the machine and it is added using swapon -a.",
   "label": "PmSwapHeaderNotFound"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Cannot find swap device",
   "advice": "An attempt to write a hibernate image to disk failed because the swap device could not be found. Make sure there is a formatted swap device on the machine and it is added using swapon -a.",
   "label": "PmCannotFindSwapDevice"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Not enough free swap",
   "advice": "Hibernate failed because the swap parition was probably too small.",
   "label": "PmNotEnoughFreeSwap"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Image device not init",
   "advice": "",
   "label": "PmImageDeviceNotInitialised"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "PM: Please power down manually",
   "advice": "",
   "label": "PMPowerDownManually"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "check_for_bios_corruption",
   "advice": "The BIOS seems to be corrupting the first 64K of memory when doing suspend\/resume. Setting bios_corruption_check=0 will disable this check.",
   "label": "PmBiosCorruptFirst64K"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "WARNING: at.*hpet_next_event",
   "advice": "Possibly an Intel I\/O controller hub HPET Write Timing issue: A read transaction that immediately follows a write transaction to the HPET TIMn_COMP Timer 0 (108h), HPET MAIN_CNT (0F0h), or TIMn_CONF.bit 6 (100h) may return an incorrect value.  This is known to cause issues when coming out of S3.",
   "label": "PmHpetWriteTimingIssue"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "tag": "FWTS_TAG_POWER_MANAGEMENT",
   "pattern": "BUG: soft lockup.*stuck for 0s",
   "advice": "Softlock errors that occur when coming out of S3 may be tripped by TSC warping.  It may be worth trying the notsc kernel parameter and repeating S3 tests to see if this solves the problem.",
   "label": "PmProcessSoftLockup"
  }
 ] 
}
