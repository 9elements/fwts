{
 "firmware_error_warning_patterns":
 [ 
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "mem=nopentium ignored! (only supported on x86_32)",
   "advice": "The kernel parameter mem=nopentium (to disable 4MB pages) was ignored as it only applies to 32 bit x86 systems.",
   "label": "KlogE8320BiosKernelParameter"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "apm: Could not register misc device",
   "advice": "APM misc device could not be registered. However, the driver can work without this, but userspace cannot control it.",
   "label": "KlogBiosApmMiscDevice"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "Could not allocate an object descriptor",
   "advice": "The ACPI driver was unable to allocate an object descriptor from the ACPI global operand cache, see acpi_ut_allocate_object_desc_dbg().",
   "label": "KlogAcpiAllocObjDescriptor"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Oops, ACPI handle corrupt in",
   "advice": "An error occurred attempting to get an ACPI handle from a kernel device structure.  The handle appears to be corrupt and invalid, so the unbinding of links to the device could not be actioned. See acpi_unbind_one(). This could be due to an ACPI kernel bug or a genenal memory corruption issue.",
   "label": "KlogAcpiHandleCorrupt"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Failed to create link",
   "advice": "The ACPI driver failed to create a sysfs link on a firmware node.  Depending on the firmware node this may impede userspace from interfacing with the firmware.  See acpi_bind_one().",
   "label": "KlogAcpiSysfsCreateLinkFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "No memory for resources",
   "advice": "An out of memory error occurred attempting to allocate resources while creating a platform device for an ACPI device node.",
   "label": "KlogAcpiPlatformDeviceNoMemory"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "kset create error",
   "advice": "The ACPI initialization failed to create the acpi_kobj kobject and so it won't appear in /sys/firmware. This may cause some user space applications difficulties if this is not created and populated. See acpi_init().",
   "label": "KlogAcpiSysfsFirmwareNotCreated"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Error creating sysfs interface for device ",
   "advice": "An error occurred when adding a new ACPI device and the sysfs interface could not be created.",
   "label": "KlogAcpiSysfsDeviceInterfaceFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Error registering device",
   "advice": "An error occurred when adding a new ACPI device, the device registration failed. See acpi_device_add().",
   "label": "KlogAcpi"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Invalid reference in package",
   "advice": "An error occurred while trying to evaluate an ACPI reference. An element in the package had a NULL reference handle.",
   "label": "KlogAcpiNullReferenceInPackage"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Invalid package element.*got string.*buffer",
   "advice": "An error occurred while trying to extract a ACPI package, got a string or a buffer in a package element, but was expecting a different type.",
   "label": "KlogAcpiInvalidPackageElement"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Invalid package element.*got number",
   "advice": "An error occurred while trying to extract a ACPI package, got an integer in a package element, but was expecting a different type.",
   "label": "KlogAcpiInvalidPackageElement"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Format specifies more objects.*than exist in package",
   "advice": "An error occurred while trying to extract an ACPI package, the format specifier specifies more object than actually exist in the package. See acpi_extract_package().",
   "label": "KlogAcpiBadFormatSpecifier"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "Deprecated procfs I/F for AC is loaded, please retry with CONFIG_ACPI_PROCFS_POWER cleared",
   "advice": "Using an old procfs interface for ACPI AC Adapter, this occurs if CONFIG_ACPI_PROCFS_POWER is enabled. This should be disabled for kernels > 2.6.37.",
   "label": "KlogAcpiDeprecatedProcfsInterface"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "Deprecated procfs I/F for battery is loaded, please retry with CONFIG_ACPI_PROCFS_POWER cleared",
   "advice": "Using an old procfs interface for ACPI battery, this occurs if CONFIG_ACPI_PROCFS_POWER is enabled. This should be disabled for kernels > 2.6.37.",
   "label": "KlogAcpiDeprecatedProcfsInterface"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "Deprecated procfs I/F for SBS is loaded, please retry with CONFIG_ACPI_PROCFS_POWER cleared",
   "advice": "Using an old procfs interface for ACPI battery, this occurs if CONFIG_ACPI_PROCFS_POWER is enabled. This should be disabled for kernels > 2.6.37.",
   "label": "KlogAcpiDeprecatedProcfsInterface"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Unsupported Throttling notifier event",
   "advice": "This is an internal ACPI driver error, an unknown processor throttling notifier event has been passed to acpi_processor_throttling_notifier().  This error is very unlikely and is an ACPI driver bug.",
   "label": "KlogAcpiUnkownCpuThrottleNotifier"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Failed to create genetlink family for ACPI event",
   "advice": "An internel kernel error occurred during  ACPI driver genetic link initialization. See acpi_event_genetlink_init() in drivers/acpi/event.c for more information.",
   "label": "KlogAcpiGenetlinkInitFail"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Can not change Invalid GPE/Fixed Event status",
   "advice": "The ACPI_EVENT_FLAG_HANDLE bit in the event status was not set which is invalid, aborting setting a GPE or Fixed Event counter.",
   "label": "KlogAcpiInvalidStatus"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "ignored .* entries of .* found",
   "advice": "The ACPI table had more sub-table entries than expected, the extra entries were ignored.",
   "label": "KlogAcpiTableLargerThanExpected"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "No return value",
   "advice": "An ACPI object evaluation failed because the caller requested a return value but the return buffer length was zero which is not enough to store the return value.",
   "label": "KlogAcpiEvalZeroBufferLength"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Blank _PRS EXT IRQ resource",
   "advice": "An error occurred evaluating an ACPI _PRS IRQ resource, the resource was NULL or the interrupt count was zero.",
   "label": "KlogAcpiBlankPrsIrqResource"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Blank _CRS EXT IRQ resource",
   "advice": "An error occurred evaluating an ACPI _CRS IRQ resource, the resource was NULL or the interrupt count was zero.",
   "label": "KlogAcpiBlankCrsIrqResource"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "BIOS reported IRQ .*, using IRQ",
   "advice": "ACPI _CRS reported that a link should be using a specific IRQ, however a different IRQ is being used for the PCI link and _CRS has been ignored.",
   "label": "KlogAcpiCrsIgnoredForPciLinkIrq"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "_CRS .* not found in _PRS",
   "advice": "This error only occurs in ACPI strict mode. An interrupt specified by _CRS was not found in the _PRS, so a PCI interrupt is chosen from the last entry of the _PRS list.",
   "label": "KlogAcpiCrsNotInPrs"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Your BIOS is broken and requested that x2apic be disabled",
   "advice": "The DMAR DMAR_X2APIC_OPT_OUT bit was set so the firmware requested that the x2apic should be disabled leading to decreased system performance.  The firmware opt out can be overridden using the intremap=no_x2apic_optout kernel parameter.",
   "label": "KlogSratEntryUnsupported"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "Found unsupported SRAT entry",
   "advice": "The kernel detected an entry in the ACPI System Resource Affinity Table (SRAT) that was not recognised. Processor local APIC/SAPIC affinity (0), Memory affinity (1) and Processory local x2APIC affinity (2) are only supported.",
   "label": "KlogSratEntryUnsupported"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "Found unsupported x2apic \\[.*\\] SRAT entry",
   "advice": "This warning occurs because NUMA x2apic affinity is not enabled. Kernel config CONFIG_ACPI_NUMA must be enabled to avoid this warning.",
   "label": "KlogSratx2apicUnsupported"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "Exceed the limit of T-state",
   "advice": "An attempt to change the throttling state to one that is outside the range of T-states as provided by the Throttling Supported States _TSS package. The last (and hence lowest performance) state has been selected instead.",
   "label": "KlogTstateLimitExceeded"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "duty_cycle spans bit 4",
   "advice": "The FADT Duty Cycle Offset and Duty Cycle Width is > 4, which means there are more than the maximum allowed 16 processor throttling states so throttling will be be disabled.",
   "label": "KlogTooManyThrottlingStates"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Invalid package argument",
   "advice": "The ACPI driver attempted to extract an ACPI package but found that the ACPI object was either NULL or was not a package or was a package that had zero elements.",
   "label": "KlogInvalidPackageArgument"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Invalid format argument",
   "advice": "The ACPI driver attempted to extract an ACPI package but found that the format was NULL or the format pointer was NULL or the format length was less than 1.",
   "label": "KlogInvalidFormatArgument"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "Invalid buffer argument",
   "advice": "The ACPI driver attempted to extract an ACPI package but found that the destination buffer was NULL.",
   "label": "KlogInvalidBufferArgument"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Limiting number of power states to max",
   "advice": "The ACPI C states object (_CST) contains more C states than ACPI supports and so the kernal has had to limit this.  To enable more C states, one must increase the Kernal ACPI macro ACPI_PROCESSOR_MAX_POWER.",
   "label": "KlogLimitPowerStates"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "Duplicate ACPI video bus devices for the same VGA controller",
   "advice": "The ACPI video driver has found a duplicate ACPI video bus device for the same VGA controller.  If the current driver does not work, one can try to work around this using the video.allow_duplicates=1 kernel parameter.",
   "label": "KlogDuplicateACPIVideoBus"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "TSC doesn't count with P0 frequency",
   "advice": "The AMD processor has the x86 constant TSC feature enabled but the firmware has not set bit 24 of the MSR MSR_K7_HWCR and so the processor TSC does not count in the P0 frequenct level. This is a firmware bug.",
   "label": "KlogAmdTscP0FreqNoCount"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "BIOS strings suggest APM bugs, disabling power status reporting",
   "advice": "The firmware is known to have broken Advanced Power Management (APM), so APM has been disabled.",
   "label": "KlogApmBiosBroken"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "BIOS strings suggest APM reports battery life in minutes and wrong byte order",
   "advice": "The firmware is known to report the battery life in minutes in the wrong byte order, so the kernel has detected this and will work around the firmware bug.  This is known to occur on many Sony laptops.",
   "label": "KlogApmMinuteSwapBytes"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Disabling ACPI support",
   "advice": "The machine has had ACPI support disabled because either the firmware is way too old, or it is known to have broken or bad ACPI support. One can try to override this with the acpi=force kernel parameter, but the machine may still hang or not work correctly.",
   "label": "KlogAcpiDisabled"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "acpi=force override",
   "advice": "The kernel has been forced to enabled ACPI. This is sometimes required because ACPI support has been disabled because the firmware is too old or was blacklisted because it has known ACPI issues.",
   "label": "KlogAcpiForceOverride"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "Invalid passive threshold",
   "advice": "The ACPI driver attempted to evaluate the ACPI Passive List (_PSL) object for a particular thermal zone but this failed. The passive cooling for that particular thermal zone has been invalidated.",
   "label": "KlogInvalidPassiveThreshold"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "Critical threshold",
   "advice": "The firmware critical trip point has been overridden using the kernel critical trip point kernel parameter crt.",
   "label": "KlogCriticalThreshold"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Found unsupported MADT entry",
   "advice": "The ACPI Multiple APIC Description Table (MADT) contains an entry that has an unknown MADT header type. This will be igored, but it does suggest a broken or buggyy ACPI MADT.",
   "label": "KlogMadtEntryUnsupported"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unknown interrupt routing model",
   "advice": "An internal ACPI driver bug has occurred. acpi_bus_init_irq has detected an unknown interrupt routing model in acpi_irq_model. This most probably is a kernel bug.",
   "label": "KlogAcpiIrqModelUnknown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "Unable to map SBF",
   "advice": "The kernel was unable to map the ACPI BOOT table and hence unable to determine the port to set the Simple Boot Flag.",
   "label": "KlogBootTableNotMapped"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "DMAR: Recommended TLB entries for ISOCH unit is 16; your BIOS set",
   "advice": "The recommended number of TLB entries for the ISOCH DMAR unit should be 16, hoever the firmware has misconfigured this.",
   "label": "KlogDmarTlbEntriesMisconfigured"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Cannot transition to non-D0 state from D3",
   "advice": "ACPI cannot transition a device from a D3 state to a non-D0 state.",
   "label": "KlogAcpiD0TransitionFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Cannot set device to a higher-powered state than parent",
   "advice": "ACPI cannot transition a device to a higher power state to that of the parent device.",
   "label": "KlogAcpiHigherPowerStateThanParent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Device \\[.*\\] failed to transition to",
   "advice": "ACPI cannot transition a device to a different power state.",
   "label": "KlogAcpiPowerStateTransitionFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _PRS IRQ",
   "advice": "The ACPI Possible Resource Settings (_PRS) object returned an invalid IRQ mapping from a PCI interrupt pin to the interrupt input of an interrupt controller.",
   "label": "KlogAcpiInvalidPrsIrq"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_INFO",
   "pattern": "firmware reports .*:.*:.* PCI INT .* connected to .*; changing to",
   "advice": "The kernel has detected a PCI interrupt configuration than needed to be quirked to make it work correctly.",
   "label": "KlogAcpiPciIntRemap"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "No IOAPIC for GSI",
   "advice": "The kernel could not find an IOAPIC that manages the Global System Interrupt (GSI), so no IOAPIC will be configured with that GSI.",
   "label": "KlogAcpiNoIoapicForGsi"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "[T|t]emperature above threshold, cpu clock throttled",
   "advice": "Test caused CPU temperature above critical threshold. The CPU has been throttled to run slower because of over-heating above the critical threshold. CPU throttling will be turned off once the CPU has cooled sufficiently.  Frequent throttling may indicate poor thermal design on the machine.",
   "label": "KlogThermalOverrun"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Possible thermal failure",
   "advice": "A Pentium class Intel CPU has had a thermal machine check exception caused by hot CPU.  If this persists it may indicate poor thermal design on the machine.",
   "label": "KlogThermalOverrun"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "BIOS never enumerated boot CPU",
   "advice": "The boot processor is not enumerated!",
   "label": "KlogBiosBootCpuNotEnumerated"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "acpi_shpchprm.*_HPP fail",
   "advice": "Hotplug _HPP method failed",
   "label": "KlogAcpiHppMethodFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "shpchp.*acpi_pciehprm.*OSHP fail",
   "advice": "ACPI Hotplug OSHP method failed",
   "label": "KlogAcpiHotplugOshpMethodFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "shpchp.*acpi_shpchprm.*evaluate _BBN fail",
   "advice": "Hotplug _BBN method is missing",
   "label": "KlogAcpiHotPlugBbnMissing"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Error while parsing _PSD domain information",
   "advice": "_PSD domain information is corrupt!",
   "label": "KlogAcpiPsdParsingError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Wrong _BBN value, reboot and use option 'pci=noacpi'",
   "advice": "The BIOS has wrong _BBN value, which will make PCI root bridge have wrong bus number",
   "label": "KlogAcpiWrongBbnValue"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*apic on CPU.* stops in C2",
   "advice": "The local apic timer incorrectly stops during C2 idle state.The ACPI specification forbids this and Linux needs the local APIC timer to work. The most likely cause of this is that the firmware uses a hardware C3 or C4 state that is mapped to the ACPI C2 state.",
   "label": "KlogAcpiApicStopsInC2"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Disabling IRQ",
   "advice": "The kernel detected an irq storm. This is most probably an IRQ routing bug.",
   "label": "KlogBiosIrqRoutingBug"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Could not enable.*event",
    "advice": "An ACPI fixed event could not be enabled. This can affect fixed events such as the power management timer, power button, sleep button, RTC alarm, wake status, system bus master request or the global release lock status.",
    "label": "KlogAcpiEventEnableFailed"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Could not disable.*events",
    "advice": "An ACPI fixed event could not be disabled. This can affect fixed events such as the power management timer, power button, sleep button, RTC alarm, wake status, system bus master request or the global release lock status.",
    "label": "KlogAcpiEventDisableFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "During return object analysis",
    "advice": "The ACPI interpreter attempted to convert or repair a return object of an unexpected type, however a fatal error occurred during the conversion.  Undefined AML execution behaviour may occur.",
    "label": "KlogAcpiObjConvertFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "MMIO size insufficient to access LTR",
    "advice": "Intel Lynxpoint Low Power Subsystem have a set of MMIO mapped registers that provide access to the LTR (Latency Tolerance Reporting).  However, the MMIO size is smaller than expected. The corresponding I/O resource for this is incorrect, it should have a resource size set to a minimum of 24 bytes.",
    "label": "KlogAcpiLpssMmioSizeTooSmall"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Error installing notify handler",
    "advice": "Failed to install a notify handler for the ACPI video driver. The ACPI video driver cannot handle notify events to change brightness levels or turn the display on/off.",
    "label": "KlogAcpiNotifyHandlerInstallFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Can't remove video notify handler",
    "advice": "Failed to remove a notify handler for the ACPI video driver. This is most probably an internal kernel issue.",
    "label": "KlogAcpiNotifyHandlerRemoveFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Could not register bus type",
    "advice": "The ACPI driver failed to register the ACPI buse type.  This is not deemed to be fatal, but it is a kernel error that should be investigated. See acpi_scan_init().",
    "label": "KlogAcpiScanBusTypeRegisterFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "failed to create clocks",
    "advice": "ACPI platform clocks failed to initialize making the creation of the platform device for the ACPI device node fail. See acpi_create_platform_device() and acpi_create_platform_clks().",
    "label": "KlogAcpiPlatformClockCreateFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "platform device creation failed:",
    "advice": "Failed to register the ACPI device node.  platform_device_register_full() failed which makes the platform device creation fail.  See platform_device_register_full() and acpi_create_platform_device().",
    "label": "KlogAcpiPlatformDeviceCreateFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "cannot add bridge to acpi list",
    "advice": "The ACPI bus scan failed and so a root bridge hotplug insertion failed.  See handle_root_bridge_insertion().",
    "label": "KlogAcpiPciRootBridgeAddFailed"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Incorrect return type .* requested .*",
    "advice": "An ACPI object find and evaluate has failed, the return object requested does not match the requested type.  This is most probably a firmware bug.",
    "label": "KlogAcpiIncorrectReturnType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unknown field access type 0x",
    "advice": "Attempted to decode an ACPI field definition failed because the firmware attempted to use an unknown access type.  Only byte, word, dword, qword and 'any' access types are allowed.",
    "label": "KlogAcpiUknownFieldAccessType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Null RegionNode",
    "advice": "Construction of an object and connecting it to a parent node failed because a region node was unexpectedly NULL. See acpi_ex_prep_field_value().",
    "label": "KlogAcpiNullRegionNode"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Null Index Object during field prep",
    "advice": "Construction of an object and connecting it to a parent node failed for a local index field. See acpi_ex_prep_field_value().",
    "label": "KlogAcpiNullIndexObject"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "No object attached to node",
    "advice": "Failed to resolve an ACPI namespace node to a valued object, there is no object attached to the given node. See acpi_ex_resolve_node_to_value().",
    "label": "KlogAcpiNoObjectAttachedToNode"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Object not a Package, type",
    "advice": "Failed to resolve an ACPI namespace node to a valued object, the source object was not an ACPI package as expected.",
    "label": "KlogAcpiObjectNotPackage"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Object not a Buffer, type",
    "advice": "Failed to resolve an ACPI namespace node to a valued object, the source object was not an ACPI buffer as expected.",
    "label": "KlogAcpiObjectNotBuffer"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Object not a String, type",
    "advice": "Failed to resolve an ACPI namespace node to a valued object, the source object was not an ACPI string as expected.",
    "label": "KlogAcpiObjectNotString"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Object not a Integer, type",
    "advice": "Failed to resolve an ACPI namespace node to a valued object, the source object was not an ACPI integer as expected.",
    "label": "KlogAcpiObjectNotInteger"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Untyped entry .* no attached object",
    "advice": "Failed to resolve an ACPI namespace node to a valued object, the source object was an ACPI ANY type and so there is no object associated with it.",
    "label": "KlogAcpiUntypedEntry"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unsupported Reference type 0x",
    "advice": "Failed to resolve an ACPI namespace node to a valued object, the source object reference class must be a table, refof or index reference class.",
    "label": "KlogAcpiUnsupportedReferenceType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Node .* Unknown object type 0x",
    "advice": "Failed to resolve an ACPI namespace node to a valued object, the source object was an unknown type.",
    "label": "KlogAcpiUnknownObjectType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid internal name",
    "advice": "An error occurred turning an ACPI internal name into an external (printable) form. The required length exceeded the intenral name length, causing a bounds error.  See acpi_ns_externalize_name().",
    "label": "KlogAcpiInvalidInternalName"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid zero length descriptor in resource list",
    "advice": "An error occurred turning an ACPI resource list into a byte stream of resources.  The resource length was zero, which is an illegal length.",
    "label": "KlogAcpiInvalidZeroLengthDescriptor"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "is not an ACPI Operand object",
    "advice": "An internal ACPI error occurred freeing an ACPI object or adding it to the object cache. The descriptor type of the given object was not a descriptor type operand.  See acpi_ut_delete_object_desc().",
    "label": "KlogAcpiNotOperandObject"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Cannot convert to external object - unsupported Reference Class .* in object",
    "advice": "An internal ACPI error occurred getting the size of a simple ACPI object. A local reference object with a reference class that was not a refclass name class is not currently supported (such as locals and args) in the ACPI driver and may need implementing. See acpi_ut_get_simple_object_size(). ",
    "label": "KlogAcpiUnsupportedReferenceClass"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Cannot convert to external object - unsupported type .* in object",
    "advice": "An internal ACPI error occurred getting the size of a simple ACPI object, the object was of a type that is not supported.",
    "label": "KlogAcpiUnsupportedType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Local index .* is invalid .*max",
    "advice": "An error occurred getting the node associated with a local or an arg. The local index for the refclass local type was greather than ACPI_METHOD_MAX_LOCAL.  See acpi_ds_method_data_get_node().",
    "label": "KlogAcpiLocalIndexInvalid"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Arg index .* is invalid .*max",
    "advice": "An error occurred getting the node associated with a local or an arg. The arg index for the refclass arg type was greather than ACPI_NETHOD_MAX_ARG.  See acpi_ds_method_data_get_node().",
    "label": "KlogAcpiArgIndexInvalid"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Type .* is invalid",
    "advice": "An error occurred getting the node associated with a local or an arg. The given type is not a refclass local or refclass arg type. See acpi_ds_method_data_get_node().",
    "label": "KlogAcpiTypeInvalid"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Null object descriptor pointer",
    "advice": "An error occurred retrieving the value of a selected Arg or Local for a method, the descriptor pointer was NULL. See acpi_ds_method_data_get_value().",
    "label": "KlogAcpiNullObjectDescriptorPtr"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Uninitialized Arg.* at node",
    "advice": "An error occurred retrieving the value of a selected Arg or Local for a method, an argument to the method was not initialised. This is probably a firmware bug. See also acpi_ds_method_data_get_value().",
    "label": "KlogAcpiUnitializedArg"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Not a Arg/Local opcode: 0x",
    "advice": "An error occurred retrieving the value of a selected Arg or Local for a method. This is probably a firmware bug. See also acpi_ds_method_data_get_value().",
    "label": "KlogAcpiNotArgLocalOpcode"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Field .* access width .* too large for region",
    "advice": "An access type is larger than a region, for example, where a region is one byte in length and a field of dword access is specified.  This is a bug in the firmware and the access to the region fails. This can lead to unexpected behaviour.",
    "label": "KlogAcpiFieldAccessWidthTooLarge"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Field .* Base.*Offset.*Width .* is beyond end of region",
    "advice": "An access exceeds the region length, in this case the base + offset + access width is larger than the region size.  For example, this could be a dword access one byte from the end of region.  This is a bug in the firmware and the access to the region fails. This can lead to unexpected behaviour.",
    "label": "KlogAcpiFieldEndOfRegion"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Region .*ID=.* not implemented",
    "advice": "An access (read or write) to an operation region has been attempted and a region for this has not been implemented, this may need to be implemented to provide the expected behaviour. See acpi_ex_access_region().",
    "label": "KlogAcpiRegionNotImplemented"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Region .*ID=.* has no handler",
    "advice": "An access (read or write) to an operation region has been attempted and a region handler for this has not been implemented, this may need to be implemented to provide the expected behaviour. See acpi_ex_access_region().",
    "label": "KlogAcpiKlogRegionNoHandler"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Index value 0x.* overflows field width 0x",
    "advice": "A write of a value larger than the maximum value that can fit into a register has be detected. The bit length of the field is not wide enough or the value is larger than expected.  This is normally a bug in the firmware. See acpi_ex_register_overflow().",
    "label": "KlogAcpiIndexValueOverflow"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Wrong object type in field I/O",
    "advice": "A read or write of a data to an I/O field failed. The object is of the wrong type. See acpi_ex_field_datum_io().",
    "label": "KlogAcpiWrongObjectType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unknown UpdateRule value: 0x",
    "advice": "An attempt to apply a field update rule to a field write failed because the update rule was unknown. See acpi_ex_write_with_update_rule().",
    "label": "KlogAcpiUknownUpdateRuleValue"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Field size .* is too large for buffer",
    "advice": "An attempt to extract the current value of a given field failed because the field size was too large for the given buffer.  See acpi_ex_extract_from_field().",
    "label": "KlogAcpiFieldSizeTooLarge"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_CRITICAL",
    "pattern": "GPE0 block .* overlaps the GPE1 block .* Ignoring GPE1",
    "advice": "An error occurred initializing the GPE data structures, the GPE0/GPE1 blocks overlap each other.  This is normally a bug in the ACPI FADT GPE block address config.",
    "label": "KlogAcpiGpe0BlockOverlapsGpe1Block"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Maximum GPE number from FADT is too large: 0x",
    "advice": "There were more than 255 GPEs specified in the FADT. The ACPI driver only supports a maximum of 255 GPEs.",
    "label": "KlogAcpiMaxGpeTooLarge"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "For GPE 0x.* found both _L.* and _E.* methods",
    "advice": "A GPE has a level _Lxx and an edge _Exx method associated with it, which is incorrect, it should have one or the other but not both.",
    "label": "KlogAcpiGpeFoundMultipleMethods"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Cannot acquire Mutex .* null thread info",
    "advice": "An attempt to acquire an ACPI AML mutex failed, the caller must have a valid thread state structure.  This is an internal ACPICA driver bug. See acpi_ex_acquire_mutex().",
    "label": "KlogAcpiMutexAcquireFailed"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Cannot acquire Mutex \\[.*\\], current SyncLevel is too large",
    "advice": "An ACPI mutex was not acquired because the sync level was too large. The per-thread sync level must be less or equal to the sync level of the method being executed.  This error occurs because the interpreter attempted to avoid possible deadlocks. See acpi_ex_acquire_mutex().",
    "label": "KlogAcpiMutexAcquireFailed"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Cannot release Mutex .* not acquired",
    "advice": "An ACPI mutex was not already previously acquired, so it cannot be released.",
    "label": "KlogAcpiMutexReleaseFailed"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Cannot release Mutex .* null thread info",
    "advice": "An ACPI mutex could not be released, the thread ID was null and not valid. This maybe an internal ACPICA bug.",
    "label": "KlogAcpiMutexReleaseFailed"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Thread .* cannot release Mutex .* acquired by thread",
    "advice": "An ACPI mutex is already owned but the thread making the mutex release is not the owner, so the release was rejected.",
    "label": "KlogAcpiMutexReleaseFailed"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Cannot release Mutex .* SyncLevel mismatch: mutex .* current",
    "advice": "An ACPI mutex could not be released, the sync level of the mutex must be equal to that of the current sync level. Attempting to release a mutex of a different level means that the mutex ordering rule has been violated.",
    "label": "KlogAcpiMutexReleaseFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Could not transition to ACPI mode",
    "advice": "A request to transfer a system into ACPI mode has failed. This could be because the ACPI FADT does not have SMI_CMD defined, or that the FADT ACPI_ENABLE and ACPI_DISABLE flags are both zero, or a SMI command failed to work.",
    "label": "KlogAcpiAcpiModeTransitionFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Hardware did not enter ACPI mode",
    "advice": "Could not transfer a system into the ACPI mode. A SMI command was issued however the system failed to transition to the ACPI mode after 3 seconds of waiting. Perhaps SMIs are broken or that the firmware cannot transition the machine to ACPI mode.",
    "label": "KlogAcpiAcpiModeNotEntered"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Could not exit ACPI mode to legacy mode",
    "advice": "A request to transfer a system into legacy BIOS mode has failed. This could be because the ACPI FADT does not have SMI_CMD defined, or that the FADT ACPI_ENABLE and ACPI_DISABLE flags are both zero, or a SMI command failed to work.",
    "label": "KlogAcpiAcpiModeToLegacyModeFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Target is not a Reference or Constant object",
    "advice": "An attempt to store an ACPI value into a location failed because the target is not a reference or a constat object. See acpi_ex_store().",
    "label": "KlogAcpiTargetNotRefOrConstantObject"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unknown Reference Class 0x",
    "advice": "An ACPI store op-code failed to execute because the an unknown reference class type was used. The store operation will fail to execute leading to undefined behaviour. This is possibly an AML compiler bug.",
    "label": "KlogAcpiUnknownRefClass"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Source must be Integer/Buffer/String type, not",
    "advice": "An attempt to store an ACPI object into an indexed buffer or package element failed because the source type is invalid. See acpi_ex_store_object_to_index().  This is most likely a firmware bug.",
    "label": "KlogAcpiBadSourceType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Target is not a Package or BufferField",
    "advice": "An attempt to store an ACPI object into an indexed buffer or package element failed beacause the targe type is not a package or a buffer field.",
    "label": "KlogAcpiTargetNotPackageOrBufferField"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "No pointer back to namespace node in buffer object",
    "advice": "An attempt to get a buffer length and initializer byte list failed because there was no pointer that referenced back to the name space node in the given buffer object.  See acpi_ds_get_buffer_arguments().",
    "label": "KlogAcpiBadPointeInBufferObject"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "No pointer back to namespace node in package",
    "advice": "An attempt to get a buffer length and initializer byte list failed because there was no pointer that referenced back to the name space node in the given package.  See acpi_ds_get_package_arguments().",
    "label": "KlogAcpiBadPointerInPackage"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Could not disable fixed event",
    "advice": "An ACPI fixed event could not be disabled, acpi_disable_event() failed to disable it.  See acpi_ev_terminate().",
    "label": "KlogAcpiFixedEventDisableFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Could not remove SCI handler",
    "advice": "The ACPI SCI handler could not be removed. See acpi_ev_terminate().",
    "label": "KlogAcpiSciHandlerRemoveFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Could not remove Global Lock handler",
    "advice": "The ACPI Global Lock Handler could not be removed. See acpi_ev_terminate().",
    "label": "KlogAcpiGlobalLockHandlerRemoveFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid/unsupported SerialBus resource descriptor: BusType 0x",
    "advice": "An ACPI resource descriptor failed a validation check, the bus type field for a serial bus resource descriptor is invalid. See acpi_ut_validate_resource().  This appears to be a firmware bug.",
    "label": "KlogAcpiBadSerialBusResourceDescriptor"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid resource descriptor length: Type 0x.*, Length 0x.* MinLength 0x.*",
    "advice": "An ACPI resource descriptor failed a validation check, the length of the resource descriptor is invalid. See acpi_ut_validate_resource().  This appears to be a firmware bug.",
    "label": "KlogAcpiInvalidResourceDescriptorLength"
  },
 {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "No results on result stack",
    "advice": "Failed to pop an object off the ACPI walk result stack, no results on the stack. This is an internal ACPICA bug and should not occur, see acpi_ds_result_pop().",
    "label": "KlogAcpiResultStackNoResults"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "No result state for result stack",
    "advice": "Failed to pop an object off the ACPI walk result stack, no result state on the stack. This is an internal ACPICA bug and should not occur, see acpi_ds_result_pop().",
    "label": "KlogAcpiResultStackNoState"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Result stack is empty! State=",
    "advice": "Failed to pop an object off the ACPI walk result stack, the result stack is NULL (empty). This is normally triggered by buggy firmware attempting to pop values off the stack when it is empty.",
    "label": "KlogAcpiResultStatckEmpty"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "No result objects on result stack, State=",
    "advice": "Failed to pop an object off the ACPI walk result stack, there were no result objects on the result stack.",
    "label": "KlogAcpiResultStatckNoResultObjects"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Result stack is full",
    "advice": "Failed to push an object onto the current ACPI result stack, the result stack is full up. This is an internal ACPICA bug.",
    "label": "KlogAcpiResultStackFull"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Failed to extend the result stack",
    "advice": "Failed to push an object onto the current ACPI result stack, the stack could not be extended.",
    "label": "KlogAcpiResultStackExtendFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "No free elements in result stack",
    "advice": "Failed to push an object onto the current ACPI result stack, there are no free element slots in the stack. This is an internal ACPICA bug.",
    "label": "KlogAcpiResultStackNoFreeElements"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "No result stack frame during push",
    "advice": "Failed to push an object onto the current ACPI result stack, there appears to be no results stack to push the object onto. This is an internal ACPICA bug.",
    "label": "KlogAcpiResultStackPushNoFrame"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Null Object! Obj=.* State=.* Num=.*",
    "advice": "Failed to push an object onto the current ACPI result stack, the object is NULL.",
    "label": "KlogAcpiResultStackNullObject"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Result stack overflow: State=.* Num=",
    "advice": "Failed to push an object onto the ACPI walk_state result stack. The stack has overflowed.",
    "label": "KlogAcpiResultStackOverflow"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Insufficient result stack size",
    "advice": "Failed to pop an object off the ACPI walk_state result stack. The result stack had insufficient objects on it to pop off.",
    "label": "KlogAcpiResultStackSizeInsufficient"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Object stack overflow.*Obj=.*State=.*",
    "advice": "Failed to push an object onto the walk state object/operand stack, a maximum of 8 operands are allowed.",
    "label": "KlogAcpiObjectStackOverflow"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Object stack underflow.*Count=.*State=.*Ops=",
    "advice": "Failed to pop an object from the walk state object/operand stack, there were no operands left on the stack.",
    "label": "KlogAcpiObjectStackUnderflow"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "is not a valid walk state",
    "advice": "Failed to delete an ACPI walk state, the given walk state is not an ACPI walk state type.  This is an internal ACPICA bug. see acpi_ds_delete_walk_state().",
    "label": "KlogAcpiWalkStateInvalid"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "walk still has a scope list",
    "advice": "Failed to delete an ACPI walk state, the walk state has an open scope list.  This is an internal ACPICA bug. See acpi_ds_delete_walk_state().",
    "label": "KlogAcpiWalkStateHasScopeList"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Target of Create Field is not a Buffer object",
    "advice": "Failed to initialise an ACPI buffer field, the target of the Create Field op is not a buffer object. This is a firmware bug.",
    "label": "KlogAcpiTargetNotBufferObject"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "destination not a NS Node",
    "advice": "Failed to initialise an ACPI buffer field, the destination is not an ACPI name space node. This is a firmware bug.",
    "label": "KlogAcpiDestinationNotNameSpaceNode"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Attempt to CreateField of length zero",
    "advice": "Failed to initialise an ACPI buffer field, CreateField used with a zero field length which is illegal. This is a firmware bug.",
    "label": "KlogAcpiZeroLengthCreateField"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unknown field creation opcode 0x",
    "advice": "Failed to initialise an ACPI buffer field, was expecting a CreateField, CreateBitField, CreateByteField, CreateWordField, CreateDWordField or a CreateQWordField opcode, but got a different AML opcode instead.  This is a firmware bug.",
    "label": "KlogAcpiUknownFieldCreationOpcode"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Field .* at .* exceeds Buffer .* size .*bits",
    "advice": "Failed to initialise an ACPI buffer field, the field exceeded the buffer size provided. This is a firmware bug.",
    "label": "KlogAcpiFieldExceedsBuffer"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": ".*bad operand.*status 0x",
    "advice": "Failed to get buffer field Buffer and Index, could not resolve operands. A call to acpi_ex_resolve_operands() failed and returned an error status code. See acpi_ds_eval_buffer_field_operands().",
    "label": "KlogAcpiBadOperand"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "No Sleep State object returned from",
    "advice": "An evaluation of the _Sx namespace object containing register values for the sleep state failed. It is entirely possible that the _Sx is broken in the firmware.  See also acpi_get_sleep_type_data():",
    "label": "KlogAcpiNoSleepStateObject"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Sleep State return object is not a Package",
    "advice": "An evaluation of the _Sx namespace object containing register values for the sleep state failed.  The kernel was expecting an ACPI package to be returned, but some different type was returned instead.  The ACPI firmware object _Sx is buggy.",
    "label": "KlogAcpiSleepStateObjectNotPackage"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "While evaluating Sleep State",
    "advice": "Failed to evaluate _Sx namespace object that contains the register values for the sleep state.",
    "label": "KlogAcpiSleepStateEvalFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Resize of Root Table Array is not allowed",
    "advice": "An attempt to resize the ACPI Root Table Array failed because the ACPI global root table flag ACPI_ROOT_ALLOW_RESIZE is not set.",
    "label": "KlogAcpiRootTableArrayResize"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Could not allocate new root table array",
    "advice": "Failed to allocate memory for the root table array.",
    "label": "KlogAcpiRootTableArrayAllocFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Bad destination type during conversion: 0x",
    "advice": "Destination type should be one of Integer, Buffer Field, Local Bank Field, Local Index Field, String or Buffer.",
    "label": "KlogAcpiBadDestinationType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unknown Target type ID 0x.* AmlOpcode 0x.* DestType",
    "advice": "An unknown target type was found in attempting to perform implicit type conversion.",
    "label": "KlogAcpiUnknownTargetTypeId"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "SMBus/IPMI/GenericSerialBus write requires Buffer, found type",
    "advice": "A SMBus, IPMI or GenericSerialBus write to a named field required a buffer to write into, but got a different type instead.",
    "label": "KlogAcpiWriteRequiresBuffer"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "SMBus/IPMI/GenericSerialBus write requires Buffer of length .*, found length",
    "advice": "A write buffer was too small.  SMBus, IPMI and GenericSerialBus writes require a buffer of size 34, 66 and 34 bytes respectively.",
    "label": "KlogAcpiWriteBufferSize"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_CRITICAL",
    "pattern": "Could not acquire AML Interpreter mutex",
    "advice": "The AML interpreter mutex could not be acquired when entering the interpreter execution region.  This is a fatal system error.",
    "label": "KlogAcpiAmlMutexAcquireFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid descriptor type 0x",
    "advice": "An invalid descriptor type was found while obtaining a reference to a target object.",
    "label": "KlogAcpiInvalidDescriptorType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid object type: 0x",
    "advice": "The ACPI interpreter failed to concatenate two objects of the same type because one or more of the types was an invalid object type. Expected types are ACPI_TYPE_INTEGER, ACPI_TYPE_STRING, ACPI_TYPE_BUFFER.",
    "label": "KlogAcpiConcatenateInvalidObjectType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Null parameter: Node .* Name 0x.* ReturnNode",
    "advice": "Either the node, target name or return node pointers were NULL when attempting to search for a name segment in a single namespace level, see acpi_ns_search_and_enter().",
    "label": "KlogAcpiNameSpaceNullParameter"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_CRITICAL",
    "pattern": "Could not allocate the GpeRegisterInfo table",
    "advice": "General Purpose Events will fail to work because the table could not be allocated.",
    "label": "KlogAcpiGpeRegisterInfoAllocFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_CRITICAL",
    "pattern": "Could not allocate the GpeEventInfo table",
    "advice": "General Purpose Events will fail to work because the table could not be allocated.",
    "label": "KlogAcpiGpeEventInfoAllocFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Bad BitWidth parameter:",
    "advice": "A hardware I/O request failed because the requested bit width of the I/O operation was not 8, 16 or 32 bits wide.  Undefined behaviour may occur.",
    "label": "KlogAcpiBadBitWidth"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Illegal I/O port address/length above 64K",
    "advice": "A hardware I/O port access was above the 64K 16 bit port address space. This is illegal and not allowed. Undefined behaviour may occur.",
    "label": "KlogAcpiIllegalIoPortAddressLength"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Need sub-package, found",
    "advice": "Failed to create a linked list of PCI interrupt descriptions, the given list did not contain a sub-package. See acpi_rs_create_pci_routing_table().",
    "label": "KlogAcpiPciRoutingTableSubPackageRequired"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Need package of length 4, found length",
    "advice": "Failed to create a linked list of PCI interrupt descriptions, a sub-package had an incorrect package length. See acpi_rs_create_pci_routing_table().",
    "label": "KlogAcpiPciRoutingTableBadPackageLength"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Address.*Need Integer, found",
    "advice": "Failed to create a linked list of PCI interrupt descriptions, a sub-package Address (element 0) was not an Integer type.",
    "label": "KlogAcpiPciRoutingTableBadPackageAddressType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Pin.*Need Integer, found",
    "advice": "Failed to create a linked list of PCI interrupt descriptions, a sub-package Pin (element 1) was not an Integer type.",
    "label": "KlogAcpiPciRoutingTableBadPackagePinType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Source.*Need name, found Reference Class 0x",
    "advice": "Failed to create a linked list of PCI interrupt descriptions, a sub-package SourceName (element 2) local reference was not an reference class name type.",
    "label": "KlogAcpiPciRoutingTableBadPackageSourceNameRefType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Source.*Need Ref/String/Integer, found",
    "advice": "Failed to create a linked list of PCI interrupt descriptions, a sub-package SourceName (element 2) was not a local reference, Integer or String type.",
    "label": "KlogAcpiPciRoutingTableBadPackageSourceNameType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "SourceIndex.*Need Integer, found",
    "advice": "Failed to create a linked list of PCI interrupt descriptions, a sub-package SourceIndex (element 3) was not an Integer type",
    "label": "KlogAcpiPciRoutingTableBadSourceIndexType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Control Method .* has no attached object",
    "advice": "An internal ACPICA error has occurred while attempting to get the next name, see acpi_ps_get_next_namepath(). This information is critical for parsing to continue correctly.",
    "label": "KlogAcpiControlMethodNoAttachedObject"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid ArgType.*0x",
    "advice": "An error occurred in getting the next simple argument was expecting one of byte data, work data, dword data, qword data, char list, name or namestring, see acpi_ps_get_next_simple_arg().",
    "label": "KlogAcpi"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "No predicate ObjDesc=.* State=",
    "advice": "An error occurred in getting the result of a predicate evaluation, a NULL operand object was found, which is unexpected. See acpi_ds_get_predicate_value().",
    "label": "KlogAcpiNullPredicateObjDesc"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Bad predicate .*not an integer.* ObjDesc=.*State=.*Type=0x",
    "advice": "The result of a predicate evaluation should be an integer but it was not. This is an unexpected error. See acpi_ds_get_predicate_value().",
    "label": "KlogAcpiBadPredicateEvalResult"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Undefined opcode type Op=",
    "advice": "Caught an unexpected opcode type, see acpi_ds_exec_end_op().",
    "label": "KlogAcpiUndefinedOpCodeType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unimplemented opcode, class=.*type=.*Opcode=.*Op=.*",
    "advice": "Caught an unexpected unimplemented opcode, see see acpi_ds_exec_end_op().",
    "label": "KlogAcpiUnimplementedOpCode"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Could not override predefined",
    "advice": "An error occurred during Name Space initialisation, a predefined name could not be overridden. This only occurs if the initial value is NULL or the value string is NULL.",
    "label": "KlogAcpiNameSpaceOverrideFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unsupported initial type value 0x",
    "advice": "An error occurred during Name Space initialisation, a predefined name initial value is of an unsupported type.",
    "label": "KlogAcpiNameSpaceOverrideBadType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "is not a namespace node",
    "advice": "A scope node is not a namespace node, this is an internal ACPICA error.",
    "label": "KlogAcpiNameSpaceNotNameSpaceNode"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "ACPI path has too many parent prefixes (^) - reached beyond root node",
    "advice": "An ACPI path has too many parent prefixes and has fallen outside the root node.  This is a bug in the firmware.  The Name Space lookup on the ACPI path cannot be found.",
    "label": "KlogAcpiPathTooManyParentPrefixes"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Could not construct external pathname; index=.*, size=.*, Path=.*",
    "advice": "Expected a zero index to a name buffer.  See acpi_ns_build_external_path().",
    "label": "KlogAcpiExternalPathNameConstructFailed"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid Namespace Node .* while traversing namespace",
    "advice": "An ACPI namespace node descriptor type was not the expected ACPI_DESC_TYPE_NAMED type. Could not get the pathname length, see acpi_ns_get_pathname_length().",
    "label": "KlogAcpiInvalidNameSpaceNodeType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unsupported object type, cannot convert to external object:",
    "advice": "Failed to copy a simple internal ACPI object to an external ACPI object, unknown internal object type.",
    "label": "KlogAcpiUtCopyBadType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unsupported object type, cannot convert to internal object:",
    "advice": "Failed to copy a simple external ACPI object to an internal ACPI object, unknown external object type.",
    "label": "KlogAcpiUtCopyBadType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Package allocation failure",
    "advice": "Failed to copy an internal ACPI package object to another internal ACPI package object, out of memory.",
    "label": "KlogAcpiPackageAllocFailure"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Needed Region, found type 0x",
    "advice": "An ACPI object type did not match the expected type, expected an ACPI Region type.",
    "label": "KlogAcpiCheckObjectTypeFailed"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Needed type .*, found .*",
    "advice": "An ACPI object type did not match the expected type.",
    "label": "KlogAcpiCheckObjectTypeFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_CRITICAL",
    "pattern": "Null stack entry at",
    "advice": "An internal ACPICA error occurred resolving operands - the ACPICA stack is either NULL or contains a NULL entry. This should not happen.",
    "label": "KlogAcpiNullStackEntry"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Bad operand object type",
    "advice": "An error occurred trying to convert multiple input operands to the types required by the target operator, see acpi_ex_resolve_operands(), the internal ACPI operand object type was not correct.",
    "label": "KlogAcpiBadOperandObjectType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Needed [Integer/String/Buffer], found",
    "advice": "An error occurred in resolving operands, required an Integer, String or Buffer type, got a different type instead.",
    "label": "KlogAcpiResolveOpBadType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Needed [Buffer/String/Package/Reference], found",
    "advice": "An error occurred in resolving operands, required an Integer, String, Package or Reference type (normally for a size_of operator), got a different type instead.",
    "label": "KlogAcpiResolveOpBadType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Needed [Buffer/String/Package], found",
    "advice": "An error occurred in resolving operands, required a Buffer, String or Package type, got a different type instead.",
    "label": "KlogAcpiResolveOpBadType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Needed [Region/Buffer], found",
    "advice": "An error occurred in resolving operands, required a Region or Buffer type, got a different type instead.",
    "label": "KlogAcpiResolveOpBadType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Needed Integer/Buffer/String/Package/Ref/Ddb], found",
    "advice": "An error occurred in resolving operands, required an Integer, Buffer, String, Package or Dbd type for a Store() operator, got a different type instead.",
    "label": "KlogAcpiResolveOpBadType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid descriptor.*\\[.*\\]",
    "advice": "Failed to resolve an ACPI operand, bad descriptor; expecting either an ACPI_DESC_TYPE_NAMED or ACPI_DESC_TYPE_OPERAND descriptor.",
    "label": "KlogAcpiInvalidDescriptor"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Internal - Unknown ARGI (required operand) type 0x",
    "advice": "Internal error in acpi_ex_resolve_operands() - found an unknown type, this should not occur.",
    "label": "KlogAcpiResolveOpBadArgType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "No init routine for region",
    "advice": "An attempt to dispatch an address space or operation region access failed because the region has never been initialised but it does not have an address space setup function.  This is a ACPI or kernel address space handler bug.  Access to the address space or operation region will fail with undefined behaviour.",
    "label": "KlogAcpiRegionHanderNoInit"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "The DSDT has been corrupted or replaced - old, new headers below",
    "advice": "Some firmware corrupts the DSDT or installs a bad new DSDT, so a workaround is to copy the DSDT. Booting with kernel parameter acpi=copy_dsdt may fix this issue.",
    "label": "KlogAcpiDsdtCorruptOrReplaced"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_CRITICAL",
    "pattern": "Could not copy DSDT of length 0x",
    "advice": "Failed to copy DSDT to local memory. Some firmware corrupts the DSDT or installs a bad new DSDT, so a workaround is to copy the DSDT.  However, the table allocation failed, which means ACPI initialisation had failed, so ACPI support is disabled.",
    "label": "KlogAcpiDsdtCopyFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Null physical address for ACPI table",
    "advice": "An attempt to install an ACPI table has failed because the physical address of the table is NULL, which is incorrect.  This could lead to ACPI failing to initialize and perhaps ACPI support being disabled.",
    "label": "KlogAcpiTableNullPhysicalAddress"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_CRITICAL",
    "pattern": "Could not map memory for table .* at",
    "advice": "The ACPI table could not me mapped into memory and was not added to the ACPI root table list.  This may lead to broken functionality.",
    "label": "KlogAcpiTableMemoryMapFailed"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Null NamedObj handle",
    "advice": "ACPI attempted to attach an ACPI object with a NULL parent node, see acpi_ns_attach_object().",
    "label": "KlogAcpiAttachNullParentNode"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Null object, but type not ACPI_TYPE_ANY",
    "advice": "ACPI attempted to attach a NULL ACPI object with a type that was not ACPI_TYPE_ANY, see acpi_ns_attach_object().",
    "label": "KlogAcpiAttachNullObjectBadType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid handle.*\\[%s\\]",
    "advice": "An attempt to attach an object with an ACPI node failed because the node was not a name handle type. This is probably an internal ACPI error. See acpi_ns_attach_object().",
    "label": "KlogAcpiInvalidHandle"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Bit offset within field too large.*0xFFFFFFFF",
    "advice": "A named field has a bit offset that is greater than the 32 bit field offset limit. An AML_INT_RESERVEDFIELD_OP 0x0031 was ignored because of the bit offset error.",
    "label": "KlogAcpiFieldOffsetTooLarge"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Field .* bit offset too large.*0xFFFFFFFF",
    "advice": "A named field has a bit offset that is greater than the 32 bit field offset limit. An AML_INT_NAMEDFIELD_OP 0x0030 was ignored because of the bit offset error.",
    "label": "KlogAcpiFieldOffsetTooLarge"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid opcode in field list: 0x",
    "advice": "An invalid opcode was found while parsing a field list. This is invariable due to buggy firmware.",
    "label": "KlogAcpiFieldListInvalidOpcode"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Attempt to dereference an Index to NULL package element Idx=",
    "advice": "An error occurred attempting to retrieve a value from an internal ACPI object. A NULL object descriptor indicates an uninitialized element in an ACPI package, and hence it cannot be deferenced. Could not retrieve a value from an internal ACPI object. See acpi_ex_resolve_object_to_value().",
    "label": "KlogAcpiNullPackageElementDereference"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Not a namespace node.*\\[.*\\]",
    "advice": "An ACPI reference was found that did not point to a namespace node. Failed to resolve. See acpi_ex_resolve_multiple().",
    "label": "KlogAcpiNotNamespaceNode"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unknown TargetType .* in Index.*Reference object",
    "advice": "An ACPI_REFCLASS_INDEX has an unknown target type. Should be a buffer field or a package. Could not retrieve a value from an internal ACPI object. See acpi_ex_resolve_object_to_value().",
    "label": "KlogAcpiUnkownTargetType"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unknown Reference type 0x.* in",
    "advice": "The ACPI object type was not a known reference type. Could not retrieve a value from an internal ACPI object. See acpi_ex_resolve_object_to_value().",
    "label": "KlogAcpiUnknownReferenceType"
  },
 {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Owner ID .* already exists",
    "advice": "A table or method owner ID allocation was attempted but the owner ID already exists.  The allocation has failed.",
    "label": "KlogAcpiOwnerIdAlreadyExists"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Could not allocate new OwnerId (255 max), AE_OWNER_ID_LIMIT",
    "advice": "A table or method owner ID allocation failed because all owner IDs (maximum of 255) are in use. This only happens if there are very deep nestings of invoked control methods or there is an ACPI bug where owner IDs are not being released.",
    "label": "KlogAcpiNoFreeOwnerIds"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid OwnerId: 0x",
    "advice": "An attempt to release an owner ID failed because the owner ID is invalud. Only owner IDs 1 to 255 are allowed.",
    "label": "KlogAcpiInvalidOwnerId"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Release of non-allocated OwnerId: 0x",
    "advice": "An attempt to release an owner ID failed because the owner ID is not already allocated. This is a double-release error.",
    "label": "KlogAcpiOwnerIdDoubleRelease"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unknown opcode 0x",
    "advice": "An invalid AML opcode in the input stream has been encountered. This will be skipped. This normally indicates buggy firmware.  Undefined behaviour may occur.",
    "label": "KlogAcpiUnknownOpcode"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Expecting bytelist, found AML opcode 0x.* in op",
    "advice": "An error occurred translating a parser object to an equivalent namespace object. This occurs when evaluating a named buffer object such as Name(xxxx, Buffer) and the buffer does not contain an AML opcode bytelist.",
    "label": "KlogAcpiByteListExpected"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unknown constant opcode 0x",
    "advice": "An error occurred initializing a namespace object from a parser op. The return type was an Integer however the opcode type was not a Zero op, One op, Ones op or Revision op. See acpi_ds_init_object_from_op().",
    "label": "KlogAcpiUnknownConstantOpcode"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unknown Integer type 0x",
    "advice": "An error occurred initializing a namespace object from a parser op. The return type was an unknown Integer type. See acpi_ds_init_object_from_op().",
    "label": "KlogAcpiUnknownIntegerType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unimplemented reference type for AML opcode: 0x",
    "advice": "An error occurred initializing a namespace object from a parser op. ACPICA has detected an unimplemented reference type. See cpi_ds_init_object_from_op().",
    "label": "KlogAcpiUnimplementedRefType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Unimplemented data type: 0x",
    "advice": "An error occurred initializing a namespace object from a parser op. ACPICA has detected an unimplemented data type. See cpi_ds_init_object_from_op().",
    "label": "KlogAcpiUnimplementedDataType"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Method reached maximum reentrancy limit (255)",
    "advice": "A method has been re-entrantly entered too many times. The limit is imposed to avoid a wrap-around on the thread count. Methods should generally not be re-entrantly executred this deep, so it may indicate a bug in the firmware.",
    "label": "KlogAcpiMethodMaxRentrancyLimit"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Cannot acquire Mutex for method .*, current SyncLevel is too large",
    "advice": "The mutex for a method was not acquired because the sync level was too large. The per-thread sync level must be less or equal to the sync level of the method being executed.  This error occurs because the interpreter attempted to avoid possible deadlocks. See acpi_ds_begin_method_execution().",
    "label": "KlogAcpiSyncLevelTooLarge"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Invalid zero thread count in method",
    "advice": "A control thread execution has terminated and the thread count is zero, which should never occur. See acpi_ds_terminate_control_method().",
    "label": "KlogAcpiZeroThreadCount"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Control method has no attached sub-object",
    "advice": "Execution of a control method has failed, there is no method object associated with the resolved node. See acpi_ns_evaluate().",
    "label": "KlogAcpiControlNoSubObject"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Evaluation of object type .* is not supported",
    "advice": "Evaluation of a device, event, mutex, region, thermal or local scope ACPI object types is not allowed. The firmware is buggy. See acpi_ns_evaluate().",
    "label": "KlogAcpiEvalObjectTypeNotSupported"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "Method has no attached sub-object",
    "advice": "An ACPI method type did not have a method object associated with the node and a NULL object was found instead. Failed to execute a control method.",
    "label": "KlogAcpiEvalMethodObjectNull"
  },
  {
    "compare_mode": "regex",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "unknown tag .* length",
    "advice": "Failed to parse the PnPBIOS resource data, an unknown tag length specifier was found. This is a bug in the firmware resource data.",
    "label": "KlogAcpiPnpBios"
  },
  {
    "compare_mode": "string",
    "log_level": "LOG_LEVEL_HIGH",
    "pattern": "no end tag in resource structure",
    "advice": "Failed to parse the PnPBIOS resource data, there was no end tag in the resource structure.",
    "label": "KlogAcpiPnpBios"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "_PRW evaluation error:",
   "advice": "The ACPI _PRW (Power Resources for Wake) object failed to evaluate when the ACPI driver was attempting to get the wakeup device flags.",
   "label": "KlogACPIPrwEvalError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "lpc_ich: Resource conflict(s) found affecting iTCO_wdt",
   "advice": "A resource conflict has occurred between ACPI OperationRegions and the same I/O region used by the lpc_ich driver for the Intel TCO (Total Cost of Ownership) timer (iTCO_wdt, this is a watchdog timer that will reboot the machine after its second expiration). According to Intel Controller Hub (ICH) specifications, the TCO watchdog has a 32 bytes I/O space resource. ACPI OperationRegions in the DSDT frequently reserve this TCO I/O space because they require access to bit 9 (DMISCI_STS) of the TCO1_STS register of the TCO, however, this bit is never used by the lpc_ich driver, so there is no risk of conflict. In the vast majority of cases this warning can be ignored as no harm will occur.",
   "label": "KlogAcpiSystemIOConflictLpcIchWatchDogTimer",
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "lpc_ich: Resource conflict(s) found affecting gpio_ich",
   "advice": "A resource conflict has occurred between ACPI OperationRegions and the same I/O region used by the lpc_ich driver for the General Purpose I/O (GPIO) region. Sometimes this GPIO region is used by the firmware for rfkill or LED controls or very rarely for the Embedded Controller System Control Interrupt. This may require deeper inspection to check if the conflict will lead to any real issues.  However, in the vast majority of cases this warning can be ignored as no harm will occur.",
   "label": "KlogAcpiSystemIOConflictLpcIchWatchDogTimer",
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "0x.*-0x.* SystemIO conflicts with",
   "advice": "A resource conflict between an ACPI OperationRegion and a native driver has been detected. By default the kernel will use a strict policy and will not allow this region to conflict and -EBUSY will be returned to the caller that was trying to allocate the already claimed region.  If an ACPI driver is available for this device then this should be used instead of a native driver, so disabling the native driver may help.  (Note that the lpc_ich driver can trigger these warnings, in which case they can generally be ignored). One can specify kernel boot parameter acpi_enforce_resources=lax to disable these checks but it may lead to random problems and system instability.  Alternatively, one can specify acpi_enforce_resources=no and ACPI Operation Region resources will not be registered.",
   "label": "KlogAcpiSystemIOConflict",
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "device .* has invalid IRQ.*check vendor BIOS",
   "advice": "An error occurred probing the PCI-Express port devices. The device has a valid pin but did not have an a valid IRQ.  This is normally due to a misconfiguration in the firmware.",
   "label": "KlogBiosIrqInvalid"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITCAL",
   "pattern": "Invalid active.* threshold",
   "advice": "The ACPI thermal driver has attempted to evaluate an ACPI active threshold control _ALx and this failed to evaluate.  This is normally due to broken or buggy _ALx control. This may lead to sub-optimal thermal control.",
   "label": "KlogAcpiAlThresholdInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "No sibling found for CPU",
   "advice": "Hyperthreading CPU enumeration failed, hyperthreads will be disabled.",
   "label": "KlogCpuNoSiblingFound"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "OHCI: BIOS handoff failed",
   "advice": "An OHCI BIOS handoff failure generally means that the OHCI driver was unable to take control of the USB controller away from the BIOS. Disabling USB legacy mode in the BIOS may help.",
   "label": "KlogBiosOhciEmulation"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "EHCI: BIOS handoff failed",
   "advice": "An EHCI BIOS handoff failure generally means that the EHCI driver was unable to take control of the USB controller away from the BIOS. Disabling USB legacy mode in the BIOS may help.",
   "label": "KlogBiosEhciEmulation"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "xHCI BIOS handoff failed",
   "advice": "An xHCI BIOS handoff failure generally means that the xHCI driver was unable to take control of the USB controller away from the BIOS. Disabling USB legacy mode in the BIOS may help.",
   "label": "KlogBiosXhciEmulation"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "MMCONFIG has no entries",
   "advice": "The ACPI MCFG has failed to be parsed, it has no entries in it. This is not expected and is most likely an ACPI misconfiguration. The PCI memory mapped configuration space is not known and hence PCI will be not configured.",
   "label": "KlogAcpiMcfgNoEntries"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "MMCONFIG not in low 4GB of memory",
   "advice": "An ACPI MCFG config entry is not in the lower 4GB (32 bit) address space and will be ignored.",
   "label": "KlogAcpiMcfgNotIn32BitMemorySpace"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "MCFG region for .* at .* is above 4GB, ignored",
   "advice": "An ACPI MCFG config entry is not in the lower 4GB (32 bit) address space and will be ignored.",
   "label": "KlogAcpiMcfgNotin32BitMemorySpace"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "disabled and referenced, BIOS bug",
   "advice": "A PCI interrupt link could not be enabled when the associated ACPI _STA control was executed. It will be disabled. This is normally a bug in the _STA control for this link.",
   "label": "KlogPciLinkDisabled"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Inconsistent FADT length .* and revision .* using FADT V1.0 portion of table",
   "advice": "The ACPI FADT was reporting to be a version 2.0 (or higher) FADT but the length was too short, so the kernel has assumed it was a version 1.0 FADT instead. The machine may have reduced ACPI 1.0 functionality.",
   "label": "KlogAcpiFadtInconsistentLength"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Disabling IRQ#",
   "advice": "The kernel had detected a spurious interrupt which is generating tens of thousands of interrupts. This can occur if the interrupt is stuck.  The kernel has taken action and disabled this interrupt.  Look at /proc/interrupts to find the devices serviced by this interrupt as these are most probably no functioning now.",
   "label": "KlogIrqDisabled"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": ", Invalid action",
   "advice": "The ACPI driver was requested to set a GPE wake mask with an incorrect action, expected ACPI_GPE_ENABLE or ACPI_GPE_DISABLE, see acpi_set_gpe_wake_mask(). This is most probably a kernel bug.",
   "label": "KlogAcpiGpeWakeMaskIncorrect"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid GPE Action,",
   "advice": "The ACPI driver was requested to enable or disable a single GPE in a parent enable register but was given an incorrect action, expected  ACPI_GPE_ENABLE or ACPI_GPE_DISABLE, see acpi_hw_low_set_gpe(). This is most probably a kernel bug.",
   "label": "KlogAcpiGpeActionInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unsupported address space: 0x",
   "advice": "The ACPI driver was requested to validate a H/W register but the address space ID was not ACPI_ADR_SPACE_SYSTEM_MEMORY or ACPI_ADR_SPACE_SYSTEM_IO.  Other address spaces are not supported by the driver. See acpi_hw_validate_register().",
   "label": "KlogAcpiHwRegsUnsupportedAddressSpace"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unsupported register bit width: 0x",
   "advice": "The ACPI driver was requested to validate a H/W register but the bit width of the register was not 8, 16 or 32 bits; other sizes are not suppoted by the driver. See acpi_hw_validate_register().",
   "label": "KlogAcpiHwRegsUnsupportedRegisterBitWidth"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid BitRegister ID: 0x",
   "advice": "The ACPI driver was requested the bitmask of a specific register ID which was greater than the the predefined driver maximum of ACPI_BITREG_MAX.  A NULL register info struct was passed back to the caller.  This is normally a driver bug, see acpi_hw_get_bit_register_info().",
   "label": "KlogAcpiHwRegsInvalidBitRegisterId"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unknown Register ID: 0x",
   "advice": "The ACPI driver was registed to read an ACPI register, but an invalid register ID was given; was expected withe a PM1 status register, PM1 enable register, PM1 control, PM 2 control, PM timer or a SMI command block.  This is normally a driver bug, see acpi_hw_register_read().",
   "label": "KlogAcpiHwRegsUnknownRegisterId"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "No handler or method for .*, disabling event",
   "advice": "A General Purpose Event (GPE) has occurred and there does not appear to be a GPE handler for this event.  This should no longer be possible with kernels dating after March 2010.  The GPE is disabled and will not occur until the machine is rebooted. See acpi_ev_gpe_dispatch().",
   "label": "KlogAcpiGpeHandlerMissing"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid SystemMemory width ",
   "advice": "The ACPI interpreter was requested to read or write to a memory region via a memory space handler but the requested field width was invalid. It expected a field with of 8, 16, 32 or 64 bits.  This is most probably an AML opregion bug.",
   "label": "KlogAcpiOpRegionInvalidSystemMemoryWidth"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not map memory at 0x.*, size",
   "advice": "The ACPI interpreter was requested to read or write to a memory region via a memory space handler but the logical address could not be mapped from the given physical address given.  This memory region is not mappable, so it could be an AML opregion bug or a bug in the kernel (less likely).",
   "label": "KlogAcpiOpRegionMemMapError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "32-bit FADT register is too long .* to convert to GAS struct - 255 bits max, truncating",
   "advice": "The Generic Address Structure bit_width was greater than 31 which is too large for a 32 bit ACPI FADT register and was truncated.  This is firmware bug.",
   "label": "KlogAcpiFadtGasBitWidthTooLong"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not install GPE interrupt handler at level 0x",
   "advice": "The ACPI driver attempted to install a General Purpose Event interrupt handler but this failed.  Is the interrupt available or already used? See acpi_ev_get_gpe_xrupt_block().",
   "label": "KlogAcpiGpeHandlerInstallFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unknown control opcode=0x.* Op=",
   "advice": "The ACPI interpreter could not execute an unknown AML opcode. This is an ACPI AML firmware bug.  See acpi_ds_exec_end_control_op().",
   "label": "KlogAcpiUnknownControlOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "No response from Global Lock hardware, disabling lock",
   "advice": "An attempt to send a global lock SMI did not generate a global lock event and so the kernel has concluded that the BIOS global lock handler is not functioning on this hardware.  All subsequent attempts to use the global lock will be flagged with an error.  You may experience race conditions in the ACPI driver.",
   "label": "KlogAcpiGlobalLockDisabled"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not signal Global Lock semaphore",
   "advice": "A global lock signal was sent to the firmware using a SMI but this failed to complete correctly.",
   "label": "KlogAcpiGlobalLockSignalError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid leading digit:",
   "advice": "An ACPI name started with a leading digit which is illegal. This is a bug in an ACPI table.",
   "label": "KlogAcpiNameLeadingDigit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Bad character 0x.* in name, at",
   "advice": "Am ACPI segment name started with some valid name characters but was shorted than the expected length of 4 characters.",
   "label": "KlogAcpiNameWrongSize"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Malformed Name at ",
   "advice": "An ACPI name had a valid prefix path but there wasn't a valid name following the prefix.",
   "label": "KlogAcpiMalformedName"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid/unknown Address Space ID: 0x",
   "advice": "The ACPI driver was attempting to create a new operation region objject as specified by an AML instruction but the provided Space ID was not one of the predefined IDs or in the user-defined range. The operation region is not created. This is an AML bug in the ACPI DSDT or SSDTs.",
   "label": "KlogAcpiAmlOpRegionInvalidAddressSpaceId"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Type returned from .* was incorrect: .*, expected Btypes: 0x",
   "advice": "The ACPI interpreter was evaluating a namespace object and discovered that the return type did not match the expected return type.  This is an ACPI AML bug in the ACPI DSDT or SSDTs.",
   "label": "KlogAcpiIncorrectReturnType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid/unsupported resource descriptor: Type 0x",
   "advice": "The ACPI interpreter failed to convert an AML resource into an aligned internal representation of the resource. The resource descriptor was not a recognised type that could be converted. This is an ACPI AML bug.",
   "label": "KlogAcpiInvalidResourceDescriptor"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid descriptor type .* in resource list",
   "advice": "The ACPI interpreter failed to convert a linked list of resources into an AML buffer because one of the resources had in invalid resource type. This may be a bug in the ACPI resource handling code.",
   "label": "KlogAcpiInvalidDescriptorType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Match operator out of range",
   "advice": "The ACPI interpreter found an AML match operator that was unrecognised, it was expecting MTR, MEQ, etc.  This is a bug in the AML.",
   "label": "KlogAcpiMatchOperatorOutOfRange"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Index .* beyond package end",
   "advice": "The ACPI interpreter was executing a 6 argument MATCH_OP op-code and discovered that the integer index being used fall outside of the package being referenced.  This is an index overflow or underflow error and is considered to be a bug in the AML.",
   "label": "KlogAcpiIndexOutOfPackageRange"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Table has invalid signature .* must be SSDT or OEMx",
   "advice": "The ACPI driver detected an ACPI table with an invalid signature. This table will not be loaded and will be ignored.",
   "label": "KlogAcpiInvalidTableSignature"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "The ACPI DSDT has been corrupted or replaced - old, new headers below",
   "advice": "The current loaded DSDT length and/or checksum differ to original version. This could be because it has been altered from outside Linux (perhaps broken firmware or a rootkit) or some incorrect memory write has corrupted the table. A workaround is to boot with the kernel parameter: acpi=copy_dsdt",
   "label": "KlogAcpiDsdtCorrupt"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Invalid signature .* for ACPI table, expected .*",
   "advice": "The ACPI DSDT and FACS tables must have correct signatures otherwise the ACPI driver treats them as suspect or corrupt and will not load them.",
   "label": "KlogAcpiTableSignatureInvalid"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Invalid table length .* in RSDT/XSDT",
   "advice": "The ACPI RSDT and XSDT must have the correct length. These variable length tables contain pointers to other ACPI tables and stated length that is different than the actual length can imply that the these tables are not trustworthy and hence the ACPI driver cannot tell if the pointers are totally valid or not.  The driver will ignore these tables and ACPI will be disabled.",
   "label": "KlogAcpiTableLengthInvalid"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Required FADT field .* has zero address and.*or length",
   "advice": "The ACPI FADT fields Pm1a_event, Pm1a_control, pm_timer are required fields that must have a defined (non-zero) address and a length that is non-zero.  One of these fields is incorrect and needs fixing.",
   "label": "KlogAcpiFadtFieldZeroAddrLength"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not convert AML resource",
   "advice": "The ACPI driver could not convert an AML resource to an internal representation of the resource that is aligned and easier to access. This is most likely to be because their is an unrecognised ACPI resource op-code.  See acpi_rs_convert_aml_to_resource() for details.",
   "label": "KlogAcpiAmlResourceConvertFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not convert resource",
   "advice": "The ACPI driver could not covert a resource linked list into an AML bytestream. See acpi_rs_convert_resources_to_aml() for details.",
   "label": "KlogAcpiResourceToAmlFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not get result from predicate evaluation",
   "advice": "The ACPI driver failed to pop a result off the result stack while evaluating a predicate. This is probably an AML code firmware bug.",
   "label": "KlogAcpiPredicateEvalPopFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "During .?egion initialization",
   "advice": "The ACPI driver failed to initialize a name space operation region. This is most probably the _REG (Region) control failed to evaluate.",
   "label": "KlogAcpiRegInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Evaluating _PRS",
   "advice": "The ACPI driver failed to evaluate the _PRS (Possible Resource Settings) object. This failure will lead to a PCI link not being added to the system.",
   "label": "KlogAcpiPrsEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Evaluating _CRS",
   "advice": "The ACPI driver failed to evaluate the _CRS (Current Resource Settings) object to get the current IRQ assignment. This failure will lead to a PCI link not allocating an IRQ.",
   "label": "KlogAcpiCrsEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Evaluating _SRS",
   "advice": "The ACPI driver failed to evaluate the _SRS (Set Resource Settings) object to set the current link resource. This failure will lead to a PCI link not allocating an IRQ.",
   "label": "KlogAcpiSrsEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "While executing method",
   "advice": "The ACPI driver attempted to execute an ACPI sleep method but this failed to execute. This is most probably an ACPI firmware bug.",
   "label": "KlogAcpiSleepMethodFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Missing or null operand",
   "advice": "The ACPI driver got a missing or NULL operand while translating a parse tree object that is an argument to an AML object. This is more likely to be poorly written or compiled AML rather than an ACPI parser bug.",
   "label": "KlogAcpiParseMissingNullOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "While creating Arg ",
   "advice": "The ACPI driver failed to convert an operator's arguments from a parse tree format to a namespace object during the parse.",
   "label": "KlogAcpiOpArgCreateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Evaluating _BST",
   "advice": "The ACPI driver attempted to get the ACPI battery state but the _BST (Battery Status) failed to evaluate. This is most likely to be a firmware or embedded controller bug. The ACPI battery state cannot be reported to userspace.",
   "label": "KlogAcpiBsrEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Evaluating _PPC",
   "advice": "The ACPI driver attempted to get the current CPU performance states but the _PPC (Performance Present Capabilities) method failed to evaluate. The CPU frequency policy will not be updated.  This may explain why CPU frequencies are locked at one setting and do not change.",
   "label": "KlogAcpiPpcEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Evaluating _PCT",
   "advice": "The ACPI driver attempted to get the CPU performance control and status registers but the _PCT (Performance Control) object failed to evaluate. This error normally occurs because the BIOS is an old or that it does not know the CPU frequencies.  CPU frequency support is not supported.",
   "label": "KlogAcpiPctEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Evaluating _PSS",
   "advice": "The ACPI driver attempted to get the CPU performance states bug the _PSS (Performance Supported States) object failed to evaluate. This error normally occurs because the BIOS is an old or that it does not know the CPU frequencies.  CPU frequency support is not supported.",
   "label": "KlogAcpiPssEvalFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Failed to write pstate_control .* to smi_command",
   "advice": "The ACPI driver attempted to update the P states but the P state control command written to the SMI command port failed to write.  This could be because that ACPI FADT SMI command or FADT P State control settings are incorrect, or that the port write just failed (which is very unlikely).",
   "label": "KlogAcpiPstateControlSmiCommandFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "AE_TIME.*Returned by Handler for.*[EmbeddedControl]",
   "advice": "This is most probably caused by when a read or write operation to the EC memory has failed because of a timeout waiting for the Embedded Controller to complete the transaction.  Normally, the kernel waits for 500ms for the Embedded Controller status port to indicate that a transaction is complete, but in this case it has not and a AE_TIME error has been returned. ",
   "label": "KlogAcpiTimeOutReturnedByHandler"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Returned by Handler for",
   "advice": "The ACPI driver detected an error returned by a region handler.",
   "label": "KlogAcpiRegionHandlerError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "from region _REG",
   "advice": "The ACPI driver detected an error when attempting to execute an ACPI_REG_DISCONNECT on a _REG (Region) method.",
   "label": "KlogAcpiRegDisconnectFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "from region handler - deactivate",
   "advice": "The ACPI driver detected an error when attempting to deactivate a region. This error is ignored.",
   "label": "KlogAcpiRegDeactivateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "While resolving operands for",
   "advice": "The ACPI driver found not resolve an operand for the AML AML_DECREMENT_OP (0x76) or AML_INCREMENT_OP (0x75) instructions. This is due to buggy AML code and not a ACPI driver bug.",
   "label": "KlogAcpiIncDecNoOperands"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not update object reference count",
   "advice": "The ACPI driver failed to update the reference count to an internal ACPI object. Reference counts are incremented when an object is attached to a node or an object is copied and decremented when an object is detected from a node.  This failure will lead to object garbage collection failing to operate correctly. This is considered a kernel bug.",
   "label": "KlogAcpiObjRefCountError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Could not write ACPI mode change",
   "advice": "The ACPI driver attempted to inform the firmware (via a System Management Interrupt) that the machine was transitioning to or from ACPI or legacy mode but this failed. This normally indicates that either SMIs are failing or the firmware is buggy. Normally if this fails to transition to ACPI mode then ACPI is not enabled.",
   "label": "KlogAcpiModeChangeFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "During name lookup/catalog",
   "advice": "The ACPI driver failed to find an object while parsing a named Op, see acpi_ps_build_named_op().",
   "label": "KlogAcpiNamedObjLookupFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invoked method did not return a value",
   "advice": "An invoked ACPI method did not return a value but it was expected to. This could lead to unexpected ACPI execution behaviour.",
   "label": "KlogAcpiMethodNoReturnValue"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "GetPredicate Failed",
   "advice": "The ACPI driver failed to get a predicate for the AML opcodes IF or WHILE. This normally is because of faulty AML code.",
   "label": "KlogAcpiIfWhilePredicateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not create predefined name",
   "advice": "The ACPI driver was initializing the ACPI namespace and adding pre-defined names but this failed on this particular object. This should not happen.",
   "label": "KlogAcpiPredefinedNameCreateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "While loading namespace from ACPI tables",
   "advice": "The ACPI driver failed to load the namespace from the DSDT and SSDTs/PSDTs found in the RSDT/XDSDT. This will lead to the ACPI driver being disabled.",
   "label": "KlogAcpiNameSpaceLoadFailure"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "While evaluating SleepState .* bad Sleep object .* type .*",
   "advice": "The ACPI driver failed to evaluate an ACPI sleep control while trying to obtain the SLP_TYPa and SLP_TYPb values for the requested sleep state.",
   "label": "KlogAcpiSlpEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "while handling a GPE",
   "advice": "The ACPI driver attempted to asynchronously execute an ACPI General Purpose Event (GPE) but this failed because the kernel ran out of free memory to allocate a GPE event information buffer.  The event was not handled, this may lead to unpredictable behaviour.",
   "label": "KlogAcpiGpeNoMemory"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "while evaluating GPE method",
   "advice": "The ACPI driver attempted to asynchronously execute an ACPI General Purpose Event (GPE) but the ACPI GPE method failed for some unknown reason. This is most likely a firmware bug.",
   "label": "KlogAcpiGpeEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unable to clear GPE",
   "advice": "An edge triggered ACPI General Purpose Event (GPE) occurred and the clearing of the GPE status bit failed. This is normally a low-level hardware I/O register write failure. This may lead to this GPE failing to be handled again.",
   "label": "KlogAcpiGpeClearFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unable to disable GPE",
   "advice": "An ACPI General Purpose Event (GPE) could not be disabled.  These are disabled to ensure the GPE does not keep firing before the asynchronous GPE handler completes.  The failure to disable the GPE may lead to further GPEs being triggered and causing some unexpected handling failures.",
   "label": "KlogAcpiGpeDisableFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unable to queue handler for GPE",
   "advice": "The ACPI driver failed to dispatch the GPE asynchronously. The GPE will not be properly handled and will be ignored.",
   "label": "KlogAcpiGpeQueueHandlerFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "During OSL initialization",
   "advice": "The ACPI driver failed to initialize, the kernel specific OS dependent layer failed to initialize. This is a kernel bug and ACPI will be disabled.",
   "label": "KlogAcpiOsLayerInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "During initialization of globals",
   "advice": "The ACPI driver failed to initialize, could not initialize the globals used by the subsystem. This is a kernel bug and ACPI will be disabled.",
   "label": "KlogAcpiGlobalsInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "During Global Mutex creation",
   "advice": "The ACPI driver failed to initialize, could not initialize the global mutex. This is a kernel bug and ACPI will be disabled.",
   "label": "KlogAcpiGlobalMutexInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "During Namespace initialization",
   "advice": "The ACPI driver failed to initialize, could not initialize the ACPI global namespace manager and root namespace tree. ACPI will be disabled.",
   "label": "KlogAcpiNamespaceInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "During OSI interfaces initialization",
   "advice": "The ACPI driver failed to initialize, could not initialize the ACPI OSI interfaces. ACPI will be disabled.",
   "label": "KlogAcpiOsiInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not create GPE Block 0",
   "advice": "The ACPI driver failed intialize the General Purpose Events (GPE) Block 0. This means that GPEs for this block will be not handled and so some devices or controls may not work correctly.",
   "label": "KlogAcpiGpeBlock0InitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not create GPE Block 1",
   "advice": "The ACPI driver failed intialize the General Purpose Events (GPE) Block 1. This means that GPEs for this block will be not handled and so some devices or controls may not work correctly.",
   "label": "KlogAcpiGpeBlock1InitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "While decoding _Lxx/_Exx methods",
   "advice": "The ACPI driver failed to decode level _Lxx or edge _Exx methods for newly added ACPI tables.",
   "label": "KlogAcpiGpeLevelOrEdgeMethodDecodeFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not enable GPE 0x",
   "advice": "The ACPI driver failed to enable a General Purpose Event (GPE).  A GPE event handler will not be executed for this GPE and this may mean some form of loss of functionality with specific devices.",
   "label": "KlogAcpiGpeEnableFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Processor Device is not present",
   "advice": "The ACPI driver has responded to an ACPI processor hotplug event and attempted to execute the _STA (Status) control for a processor but this failed. _STA is mandatory for a processor that supports hot plug and so the driver has not added the processor to the running system.",
   "label": "KlogAcpiCpuHotPlugStaFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not install PciConfig handler for Root Bridge",
   "advice": "The ACPI driver could not install a PCI Config operation region for a PCI Root Bridge. This could occur for a variety of reasons but it is most probably because the devices _REG (Region) control failed.",
   "label": "KlogAcpiPciConfigInstallFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "During WalkNamespace",
   "advice": "The ACPI driver failed to traverse the ACPI namespace either during namespace initialization. ACPI will be disabled. ",
   "label": "KlogAcpiWalkNamespaceFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "During device initialization",
   "advice": "The ACPI driver failed to traverse the ACPI namespace and initialize all the ACPI devices.",
   "label": "KlogAcpiNsDevInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not execute arguments for",
   "advice": "The ACPI driver failed to initialize methods or op regions during the namespace traversal.",
   "label": "KlogAcpiNsExecArgFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI thermal trip point .* changed",
   "advice": "The ACPI driver has thrown this exeption because of one of the two cases: 1. Either a trip point has becomes invalid when re-evaluating the AML code or, 2. devices listed in _PSL, _ALx or _TZD may have changed and the driver needs to re-bind to the cooling devices of a thermal zone when that happens.  This execption probably means the ACPI thermal driver needs to cater for this behaviour and it needs fixing or updating.",
   "label": "KlogAcpiThermTripPointChanged"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Cannot find acpi parent",
   "advice": "The ACPI driver was attempting to notify a memory device but could not find a parent to the given device handle. This is an internal ACPI driver error and should not occur.  ACPI memory hotplug failures may occur because of this failure.",
   "label": "KlogAcpiMemHotPlugParentError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "_EJ0 failed",
   "advice": "The ACPI driver attempted to power down a memory hot plug device but the ACPI _EJ0 (Eject) control failed which leaves the hotplug memory device in an invalid state.",
   "label": "KlogAcpiMemHotPlugEj0Failed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "walk_namespace failed",
   "advice": "The ACPI driver failed to traverse the ACPI object namespace to allow it to register any memory hotplug notify handlers. This failure means that ACPI memory hotplug will not work.",
   "label": "KlogAcpiMemHotPlugInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "failed to execute _DCK",
   "advice": "The ACPI driver executed the _DCK (Dock) control but this failed to complete successfully. This control is executed when an ACPI docking or undocking event is received.  This may be because of a fault _DCK control or that the hardware isn't functioning correctly.",
   "label": "KlogAcpiDckEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Evaluating _DOD",
   "advice": "The ACPI driver failed to enumerate the ACPI video devices because the _DOD (Enumerate All Devices Attached to the Display Adapter) control failed.  This may explain why the video device is not functioning correctly.",
   "label": "KlogAcpiDodEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _DOD data",
   "advice": "The ACPI control _DOD (Enumerate All Devices Attached to the Display Adapter) returned either a NULL package or not did not return an ACPI_PACKAGE type as expected.  This may explain why the video device is not functioning correctly.",
   "label": "KlogAcpiDodInvalidData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid GPE 0x",
   "advice": "The ACPI driver was requested to get the status of a ACPI General Purpose Event or Fixed Event that did not exist. This is an unexpected driver error.",
   "label": "KlogAcpiInvalidGpe"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Evaluating _PRT",
   "advice": "The ACPI driver failed to get the PCI Routing Table for a device because the evaluation of _PRT (PCI Routing Table) failed. This will lead to the device not having the IRQ wired up to the correct slot/device/pin. Without this, the device cannot handle interrupts and will fail to work. ",
   "label": "KlogAcpiPrtEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Attempted physical table override failed",
   "advice": "The ACPI driver attempted to physically map an ACPI table but this failed.  This table will not be used and this can lead to unexpected behaviour and loss of functionality.",
   "label": "KlogAcpiTablePhysMapFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Could not acquire Global Lock",
   "advice": "The ACPI Global Lock is a mutex that ensures exclusive access to resources controlled by the ACPI driver. This lock failed to be acquired which normally means that the kernel mutex has failed, which should never occur.  This is normally considered a kernel bug.",
   "label": "KlogAcpiGlobalLockAcquireFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Could not release Global Lock",
   "advice": "The ACPI Global Lock is a mutex that ensures exclusive access to resources controlled by the ACPI driver. This lock failed to be release which normally means that the kernel mutex has failed, which should never occur.  This is normally considered a kernel bug.",
   "label": "KlogAcpiGlobalLockReleaseFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Error in acpi_memory_enable_device",
   "advice": "ACPI memory hotplug failed to add a memory device, acpi_memory_enable_device() failed. This occurs if the memory block has already been used by the kernel or if add_memory() failed.",
   "label": "KlogAcpiMemHotPlugFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Error reading AC Adapter state",
   "advice": "The ACPI driver could not read the AC adapter state because the ACPI control _PSR (Power Source) failed to evaluate. This could be because this control did not exist or more probably that it failed to execute because of an error between the firmware and the smart battery.",
   "label": "KlogAcpiPsrEvalFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "failed to add I2C device .* from ACPI",
   "advice": "Failed to create an I2C device while walking through the ACPI namespace enumerating I2C slave devices behind the adapter.",
   "label": "KlogAcpiI2CAddFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Cannot turn wakeup power resources on",
   "advice": "The ACPI driver was preparing to wakeup a device by powering on the power resources required for the device but one of these resources failed to power on.  See acpi_enable_wakeup_device_power().",
   "label": "KlogAcpiPowerWakeupResources"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Cannot turn wakeup power resources off",
   "advice": "The ACPI driver was preparing to shutdown a wakeup device by powering off the power resources for the device but one of these resources failed to power off. See acpi_disable_wakeup_device_power().",
   "label": "KlogAcpiPowerWakeupResources"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Failed to evaluate processor object",
   "advice": "ACPI Processor() failed to evaluate. ACPI could not gather information on a CPU which will lead to it not being used.",
   "label": "KlogAcpiProcessorEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Failed to evaluate processor _UID",
   "advice": "ACPI failed to evaluate a processor _UID object (as declared in a Device statement).  ACPI could not gather information on a CPU which will lead to it not being used.",
   "label": "KlogAcpiProcessorEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Evaluating _TPC",
   "advice": "The ACPI driver failed to get the current number of supported CPU throttling T States because the ACPI control _TPC (Throttling Present Capabilities) failed to evaluate.",
   "label": "KlogAcpiTpcEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Evaluating _PTC",
   "advice": "The ACPI driver failed to get the Processor Throttling Control because the ACPI control _PTC failed to evaluate. This option control defines a processor throttling control interface alternative to the I/O address spaced-based P_BLK throttling control register (P_CNT).  Without this the CPU cannot be throttled via this interface.",
   "label": "KlogAcpiPtcEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Evaluating _TSS",
   "advice": "The ACPI driver failed to get the Throttling Supported States because the ACPI control _TSS failed to evaluate. Processor throttling will not be enabled.",
   "label": "KlogAcpiTssEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _TSS data: freq is zero",
   "advice": "The ACPI driver got invalid data from the ACPI control _TSS (Throttling Supported States). One of the CPU throttling frequencies in the _TSS package is zero, which is invalid. Processor throttling will not be enabled.",
   "label": "KlogAcpiTssPackageFreqZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _TSS data",
   "advice": "The ACPI driver got invalid data from the ACPI control _TSS (Throttling Supported States). Either the package was NULL or the data returned was not of type ACPI_PACKAGE.",
   "label": "KlogAcpiTssPackageInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Evaluating _TSD",
   "advice": "The ACPI driver could not get the T-State Dependency from the ACPI control _TSD. This means that the CPU will not have any throttling coordination with other CPUs",
   "label": "KlogAcpiTsdEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _TSD data",
   "advice": "The ACPI driver got invalid data from the ACPI control _TSD (T-State Dependency). Either the package was NULL or the data returned was not of type ACPI_PACKAGE or the number of elements in the package was incorrect or the package in element zero could not be extracted.",
   "label": "KlogAcpiTsdDataInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Evaluating _PRW",
   "advice": "The ACPI driver failed to evaluate the ACPI control _PRW (Power Resources for Wake). As a result, wakeup device management will not function.",
   "label": "KlogAcpiPrwEvalFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Extracting _PRW package",
   "advice": "The ACPI driver got invalid data from the ACPI control _PRW (Power Resources for Wake). The returned data did not conform to the ACPI specification, see section 7.2.13 of the ACPI 5.0 ACPI specification for more details.",
   "label": "KlogAcpiPrwDataInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Notifying BIOS of _CST ability failed",
   "advice": "The ACPI driver attempted to notify the firmware (using a System Management Interrupt) that the system had _CST (C-State) ability but this notify command failed. This may lead to unexpected C-State behaviour.",
   "label": "KlogAcpiSmiCstFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Evaluating _PIC",
   "advice": "The ACPI driver attempted to inform the firmware which method of interrupt routing was being used via the _PIC method, however, this failed to execute.  This results in ACPI being disabled.",
   "label": "KlogAcpiPicEvalFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Mutex .* is not acquired, cannot release",
   "advice": "An attempt to release (unlock) an ACPI related mutex has occurred. This mutex could not be released. This is most probably a bug in the AML code where a Release opcode has been executed that does not match up with an earlier corresponding Mutex opcode. It may also be a bug in the ACPI driver, but this is less likely.",
   "label": "KlogAcpiMutexReleaseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Thread .* could not acquire Mutex",
   "advice": "A mutex could not be acquired (locked) and the ACPI driver has flagged this up as an exception error. If this occurs when executing a AML Mutex opcode there could be race condition errors if the AML is not checking the return from the Mutex operation and a lot of firmware does omit this check.",
   "label": "KlogAcpiMutexAcquireError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Unable to initialize fixed events",
   "advice": "The ACPI driver failed to initialize the structure that keeps track of fixed event handlers.  The failure occurred when trying to disable one of the 4 fixed events and this causes the ACPI subsystem initialization to fail, which disables ACPI support.",
   "label": "KlogAcpiFixedEventInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Unable to initialize general purpose events",
   "advice": "The ACPI driver failed to initialize the General Purpose Event (GPE) blocks as defined in the ACPI FADT. This in turn causes the ACPI subsystem initialization to fail, which disables ACPI support.",
   "label": "KlogAcpiGpeInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Unable to install System Control Interrupt handler",
   "advice": "The ACPI driver failed to install the System Control (SCI) interrupt handler, which has to be working for ACPI to work correctly. This in turn causes the ACPI subsystem initialization to fail, which disables ACPI support.",
   "label": "KlogAcpiSciHandlerInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Unable to initialize Global Lock handler",
   "advice": "The ACPI driver failed to initialized the Global Lock handler, which is basically a kernel mutex (and should not fail). This in turn causes the ACPI subsystem initialization to fail, which disables ACPI support.",
   "label": "KlogAcpiGlobalLockInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "No installed handler for fixed event",
   "advice": "The ACPI driver failed to dispatch a fixed event because their is no fixed event handler installed for this event. This is an error and the kernel has disabled this event for further interrupts. This could lead to reduced functionality.",
   "label": "KlogAcpiNoFixedEventHandler"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Index .* is beyond end of object",
   "advice": "The ACPI interpreter could not execute an AML index opcode, the index in the first operand is out of range.",
   "label": "KlogAcpiIndexOverflow"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unexpected notify object type",
   "advice": "The ACPI interpreter could not execute a AML notify opcode because the first operand is not a notify object.  This is a bug in the firmware.",
   "label": "KlogAcpiUnexpectedNotifyObjType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Sleep values out of range: A=.* B=.*",
   "advice": "An attempt to transition to a sleep state has occurred with the ACPI sleep type values for the PM controls set greater than the maximum allowed value of 7. This is an illegal value and the system will not be transistioned to this sleep state. ",
   "label": "KlogAcpiSleepValuesRangeError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unknown exception code: 0x",
   "advice": "An execption occurred but the execption code was not recognized and the ACPI driver could not find a textual description for this exception. This is most probably a bug in the ACPI driver or ACPICA core.",
   "label": "KlogAcpiUnknownExceptionCode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unknown Reference Count action (0x",
   "advice": "An internal ACPI error occurred attempting to update an object reference count.  An incorrect action type was provided, expected REF_INCREMENT or REF_DECREMENT, see acpi_ut_update_ref_count().",
   "label": "KlogAcpiUnknownRefCountAction"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid type .* for target of Scope operator .*Cannot override",
   "advice": "The ACPI interpreter found an invalid type for target of a scope operator, this occurred during the loading of the ACPI tables, see acpi_ds_load2_begin_op().",
   "label": "KlogAcpiInvalidTypeScopeOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Divide by zero",
   "advice": "The ACPI interpreter detected a zero divisor which produce a division by zero error.  The AML code is buggy and this will return an undefined value that may cause unexpected behaviour.",
   "label": "KlogAcpiAmlDivideByZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not release AML Interpreter mutex",
   "advice": "The ACPI AML interpreter attempted to release the mutex but this failed. The next time interpreter will attempt to acquire this mutex it will fail, however it will continue to execute AML but there will be race conditions occurring.",
   "label": "KlogAcpiAmlMutexNotReleased"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Could not map memory at 0x.* for length",
   "advice": "ACPI could not memory map the Extended BIOS Data Area (EBDA) or upper region 0xE0000-0xFFFFF to search for the ACPI RSDP.  This normally results in the RSDP not being found, which means the ACPI tables can't be located and hence ACPI is disabled.",
   "label": "KlogAcpiRsdpMemMap"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Invalid zero ID from AcpiOsGetThreadId",
   "advice": "A zero thread ID was returned which will break the ACPI driver.  This should never happen, since the thread ID is actually the address of the thread descriptor which is never zero.",
   "label": "KlogAcpiZeroThreadId"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Unknown action (0x",
   "advice": "The ACPI engine was expecting to increment, decrement or delete a reference count but instead was given an uknown action to do instead.  This is a bug in the ACPI ACPICA code.",
   "label": "KlogAcpiRefCountUnknownAction"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Null Op",
   "advice": "The ACPI interpreter found a NULL parse opcode and didn't expect to. See acpi_ds_delete_result_if_not_used() or acpi_ds_is_result_used().",
   "label": "KlogAcpiNullOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Unknown parent opcode Op=",
   "advice": "The ACPI interpreter found an AML opcode that had an unexpected parent class. This probably indicates an internal ACPI interpeter bug. ",
   "label": "KlogAcpiUnknownParentOp"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Time parameter is too large",
   "advice": "ACPI Stall() op was requested to wait for more than 255 usec.  The ACPI specification states that the maximum should be 100 usec but to accommodate some firmware a maximum of 255 is supported by the kernel.",
   "label": "KlogAcpiStallTooLarge"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Evaluating _BCM failed",
   "advice": "Could not set the brightness level, the ACPI control _BCM failed to execute correctly.",
   "label": "KlogAcpiBcmFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Current brightness invalid",
   "advice": "The ACPI video driver set the brightness level using the ACPI control _BCM, however the level used was not a known level (as returned by _BCL).",
   "label": "KlogAcpiInvalidBrightness"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Too many duplicates in _BCL package",
   "advice": "ACPI method _BCL (Query List of Brightness Control Levels Supported) contains too many duplicated brightness levels in the returned package and this is non-standard.",
   "label": "KlogAcpiBclPackageContainsDuplicates"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Found unordered _BCL package",
   "advice": "ACPI method _BCL (Query List of Brightness Control Levels Supported) has a maximum brightness value which is not the last value in the returned package. Values returned must be in ascending order.",
   "label": "KlogAcpiBclUnorderedPackage"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "ACPI Subsystem is already terminated",
   "advice": "A request to terminate the ACPI driver but it is already terminated. You should not see this error.",
   "label": "KlogAcpiAlreadyTerminated"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Null scope parameter",
   "advice": "Failed to push the current scope onto the scope stack, the node was Null, which was not expected. See acpi_ds_scope_stack_push().",
   "label": "KlogAcpiNullScopeParameter"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Invalid conversion sub-opcode",
   "advice": "The ACPI driver could not convert an AML resource descriptor to a corresponding internal resource descriptor. Refer to acpi_rs_convert_aml_to_resource() or acpi_rs_convert_resource_to_aml().",
   "label": "KlogAcpiConversionSupOpcode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Invalid conversion opcode",
   "advice": "The ACPI driver could not convert an AML resource descriptor to a corresponding internal resource descriptor. Refer to acpi_rs_convert_aml_to_resource() or acpi_rs_convert_resource_to_aml().",
   "label": "KlogAcpiConversionSupOpcode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "No SMI_CMD in FADT, mode transition failed",
   "advice": "ACPI FADT SMI_CMD is zero, with ACPI 2.0 this means that the system cannot transition to/from ACPI mode.",
   "label": "KlogAcpiFadtSmiCmdZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "No ACPI mode transition supported in this system (enable/disable both zero)",
   "advice": "ACPI FADT ACPI_ENABLE is zero and ACPI_DISABLE is set, ACPI 2.0 this means enabling or disabling is not supported and the system cannot transition to ACPI mode.",
   "label": "KlogAcpiNoModeTransitionSupport"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Found a grandchild.*P=.*C=",
   "advice": "An error occurred in the ACPI driver, acpi_ns_delete_children() was trying to delete children objects and discovered that one of these had children objects of it's own, which should not happen.",
   "label": "KlogAcpiObjectGrandchild"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Cannot assign type .* to .*must be type Int/Str/Buf",
   "advice": "ACPI execution run time error: Type assignment was illegal, acpi_ex_resolve_object() was trying assign a type to a different type which is illegal.",
   "label": "KlogAcpiTypeAssign"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Store into an unresolved Alias object",
   "advice": "ACPI execution run time error: The ACPI driver has been asked to resolve an object of type ACPI_TYPE_LOCAL_ALIAS or ACPI_TYPE_LOCAL_METHOD_ALIAS but this should not occur as these should have been resolved earlier. See function acpi_ex_resolve_object() for more details.",
   "label": "KlogAcpiUnresolveAliasObject"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unknown AML opcode 0x",
   "advice": "ACPI execution run time error: The ACPI interpreter has reached an opcode that is unknown, this normally is a bug in the underlying AML code either because of badly written AML code or the compiler has produced code that is incorrect or the ACPI interpreter does not support this valid opcode. ",
   "label": "KlogAcpiUnknownAmlOpcode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid AML Opcode: 0x",
   "advice": "ACPI execution run time error: The ACPI interpreter has reached an opcode that is unknown, this normally is a bug in the underlying AML code either because of badly written AML code or the compiler has produced code that is incorrect or the ACPI interpreter does not support this valid opcode. ",
   "label": "KlogAcpiUnknownAmlOpcode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Found unknown opcode .* at AML address .* offset",
   "advice": "ACPI execution run time error: The ACPI interpreter has reached an opcode that is unknown, this normally is a bug in the underlying AML code either because of badly written AML code or the compiler has produced code that is incorrect or the ACPI interpreter does not support this valid opcode. ",
   "label": "KlogAcpiUnknownAmlOpcode"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "BCD digit too large (not decimal): 0x",
   "advice": "ACPI execution run time error: AML opcode AML_FROM_BCD_OP (0x5b28) contains a BCD digit value that is greater than 9 and is out of range for a Binary Coded Decimal digit.",
   "label": "KlogAcpiBcdDigitTooLarge"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Integer too large to convert to BCD",
   "advice": "ACPI execution run time error: AML opcode AML_TO_BCD_OP (0x5b29) has been requested to convert an integer into a Binary Coded Decimal value that is too large. An overflow has been caught and it is possible that unexpected execution behaviour will occur.",
   "label": "KlogAcpiToBcdOverflow"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "obsolete and not implemented",
   "advice": "ACPI execution run time error: Execution of AML_SHIFT_LEFT_BIT_OP (0x5b11) or AML_SHIFT_RIGHT_BIT_OP (0x5b10) were ignored, these are obsolete AML opcodes and are not implemented in the ACPI interpreter. Unexepcted execution behaviour will occur.",
   "label": "KlogAcpiOpObsolete"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Operand must be Buffer/Integer/String/Package - found type",
   "advice": "ACPI execution run time error: Execution of AML_SIZE_OF_OP with an operand that is not a buffer, integer, string or package has occurred. This will result in unexpected behaviour. This is a bug in the AML.",
   "label": "KlogAcpiOpTypeBad"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Unknown Index TargetType 0x",
   "advice": "ACPI execution run time error: Execution of AML_DEREF_OF_OP (0x83) with an illegal target index operator that was not a buffer or a package type.",
   "label": "KlogAcpiUnknownIndexTargetType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Unknown class in reference",
   "advice": "ACPI execution run time error: Execution of AML_DEREF_OF_OP (0x83) with an illegal operand reference class.",
   "label": "KlogAcpiUnknownIndexTargetType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "apm.*an event queue overflowed",
   "advice": "More then 20 APM events were queued up which is unexpected.  The queue was not being drained quickly by a reading process (perhaps it is not running).",
   "label": "KlogApmEventQueueOverflow"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "apm.*passed bad filp",
   "advice": "A read of the APM events was performed by a reading process with an unrecognised file pointer. This should not happen.",
   "label": "KlogApmReadBadFileptr"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "apm.*filp not in user list",
   "advice": "An attempt to release a APM reader occurred using an unrecognised file pointer. This should not happen.",
   "label": "KlogApmReleaseBadFileptr"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "apm.*cannot allocate struct of size %d bytes",
   "advice": "An attempt to open failed, out of memory. APM events cannot be read.",
   "label": "KlogApmOpenNoMemory"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "apm.*disabled - Unable to start kernel thread",
   "advice": "Cannot start kernel APM thread, APM handling will be disabled.",
   "label": "KlogApmKernelThreadFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PnPBIOS.*ESCD size reported by BIOS escd_info call is too great",
   "advice": "The ESCD size was greater than a sane size of 32K.",
   "label": "KlogPnpBiosEscdSize"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PnPBIOS.*ESCD size reported by BIOS read_escd call is too great",
   "advice": "The ESCD size was greater than a sane size of 32K.",
   "label": "KlogPnpBiosEscdSize"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_INFO",
   "pattern": "PnPBIOS.*Disabled by ACPI PNP",
   "advice": "The PnPBIOS driver was disabled because PnP support is provided by the ACPI driver.",
   "label": "KlogPnpBiosDisabled"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PnPBIOS.*",
   "advice": "The PnPBIOS driver has detected an issue that fwts does not know about.",
   "label": "KlogPnpBiosError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Node number .* is out of sequence following node .* Aborting.",
   "advice": "Device node numbers are out of sequence.",
   "label": "KlogPnpBiosDevNodeSeqError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "PCI: BIOS BUG #",
   "advice": "A call to the PCI BIOS32 service routine (with service signature $PCI) has returned a bad status or an illegal PCI signature. The kernel will disable the use of the PCI BIOS.",
   "label": "KlogBios32PciFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "e820: too many entries; ignoring ",
   "advice": "Legacy E820 BIOS has a limit of 128 entries in the E820 memory map but the firmware seems to have more than this. For EFI Numa hardare, the limit is 128 + 3 * maximum number of nodes.  The kernel has ignore the extra entries.  This could lead to regions of memory being used by the kernel when in fact is should be reserved and this can lead to unexpected behaviour.",
   "label": "KlogE820TooManyEntries"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Ooops! Too many entries in the memory map!",
   "advice": "Legacy E820 BIOS has a limit of 128 entries in the E820 memory map but the firmware seems to have more than this. For EFI Numa hardare, the limit is 128 + 3 * maximum number of nodes.  The kernel has ignore the extra entries.  This could lead to regions of memory being used by the kernel when in fact is should be reserved and this can lead to unexpected behaviour.",
   "label": "KlogE820TooManyEntries"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": "MTRR.*CPU.*SYSCFG.*MtrrFixDramModEn.*not cleared by BIOS, clearing this bit",
   "advice": "The firmware is expected to clear MtrrFixDramModEn bit, see for example BIOS and Kernel Developer's Guide for the AMD Athlon 64 and AMD Opteron Processors (26094 Rev. 3.30 February 2006), section 13.2.1.2 SYSCFG Register. The MtrrFixDramModEn bit should be set 1 during firmware initialization of the fixed MTRRs, then cleared to 0 for operation. Hence the kernel has detected and worked around this fault.",
   "label": "KlogMtrrFixDramModEnNotClear"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "MTRR.*CPU.*Writing MSR .* to .* failed",
   "advice": "Writing to a MTRR MSR has failed. The kernel cannot do much about this and has ignored the failure.",
   "label": "KlogMtrrWriteMsrFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "acpi_request_vector.*invalid interrupt type",
   "advice": "An attempt to request an interrupt vector greater than 256 (ACPI_MAX_PLATFORM_INTERRUPTS) has occurred and will be rejected.",
   "label": "KlogAcpiIa64RequestBadVector"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*Can't find MADT",
   "advice": "Could not find the ACPI MADT. The kernel could not find this table so it could determine how many CPUs the system had.  The machine will boot with just one CPU which may be the incorrect number of CPUs.",
   "label": "KlogAcpiMadtMissing"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*Error parsing MADT - no LAPIC entries",
   "advice": "The ACPI MADT could not be parsed to determine the number of Local APIC entries.  This may lead to sub-optimal configuration of the machine.",
   "label": "KlogAcpiMadtLapicParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*Error parsing LAPIC address override entry",
   "advice": "The ACPI MADT could not be parsed to determine the Local APIC override entry.",
   "label": "KlogAcpiMadtLapiceOverrideParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*Error parsing LAPIC NMI entry",
   "advice": "The ACPI MADT could not be parsed to determine the Local APIC NMI entry.",
   "label": "KlogAcpiMadtLapicNmiParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*Error parsing MADT.*no IOSAPIC entries",
   "advice": "The ACPI MADT could not be parsed to find the IOSAPIC entries.",
   "label": "KlogAcpiMadtIosapicParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*Error parsing platform interrupt source entry",
   "advice": "The ACPI MADT could not be parsed to find the platform intrerrupt source entry.",
   "label": "KlogAcpiMadtPlatIntSrcParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*Can't find FADT",
   "advice": "The ACPI Fixed ACPI Description Table (FADT) is missing and so the kernel cannot determine if the legacy keyboard controller is present.  It cannot also determine the SCI_INT interrupt line which is used for ACPI events, such as the power and sleep buttons. If the SCI_INT is not on a legacy interrupt then it needs to be specified in the FADT. ",
   "label": "KlogAcpiFadtMissing"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*Cannot create",
   "advice": "The ACPI driver attempted to create an entry in /proc/acpi but failed. This should not happen and is a kernel bug.",
   "label": "KlogAcpiProcfsCreateFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*Create sysfs link",
   "advice": "The ACPI driver attempted to create a sysfs link for a device and this failed. This should not happen and is a kernel bug.",
   "label": "KlogAcpiSysfsLinkCreateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Error updating fan power state",
   "advice": "Failed to update the fan power state when coming out of resume. The call to acpi_bus_update_power() failed even though the fan device was valid.",
   "label": "KlogAcpiFanResumeUpdate"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "does not support this state",
   "advice": "A request to suspend the machine was aborted because it was asked to transition to a sleep state that is not supported by the ACPI driver or this machine.",
   "label": "KlogAcpiUnsupportedSleepState"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Hardware changed while hibernated, cannot resume",
   "advice": "The FACS hardware signature has changed when coming out of hibernation. The kernel has concluded that the machine has changed and therefore won't commit to resuming from hibernate.",
   "label": "KlogAcpiS4ResumeBadFacsSignature"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Device don't exist, dropping EJECT",
   "advice": "A processor hotplug notify eject request event was rejected because the device does not seem to exist.",
   "label": "KlogAcpiHotPlugEjectMissingDevice"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Driver data is NULL, dropping EJECT",
   "advice": "A processor hotplug notify eject request event was rejected because the device data is NULL.",
   "label": "KlogAcpiHotplugEjectNullDeviceData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid reference to IOAPIC pin",
   "advice": "The IOAPIC pin was invalid, it exceeded the maximum expected pin reference value (MP_MAX_IOAPIC_PIN 127).",
   "label": "KlogAcpiIoApicPinRefInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Error parsing IOAPIC entry",
   "advice": "Failed to parse the ACPI MADT, the number of IOAPIC entries found was less than zero, which probably means the MADT is broken.",
   "label": "KlogAcpiMadtParseError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "No IOAPIC entries present",
   "advice": "The ACPI MADT was expected to contain at least one IOAPIC entry, however, none were found. Cannot enumerate the IOAPICs.",
   "label": "KlogAcpiMadtNoIoApicEntry"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Error parsing interrupt source overrides entry",
   "advice": "Could not parse the ACPI MADT to determine the interrupt override for the SCI. This could lead to unexpected behaviour.",
   "label": "KlogAcpiMadtIrqOverrideParseError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Error parsing NMI SRC entry",
   "advice": "Could not parse the ACPI MADT to determine the NMI SRC entry. This could lead to unexpected behaviour.",
   "label": "KlogAcpiMadtNmiSrcEntryParseError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "pci_create_slot returned",
   "advice": "A PCI slot could not be register because a call to pci_create_slot() failed.",
   "label": "KlogAcpiPciSlot"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "walk_p2p_bridge failure",
   "advice": "Traversing the PCI root bridge failed because of an error walking the P2P bridge.",
   "label": "KlogAcpiPciSlot"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "register_slot failure",
   "advice": "Adding a PCI slot failed because traversing the PCI root bridge failed.",
   "label": "KlogAcpiPciSlot"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "_PRS resource type .* isn't an IRQ",
   "advice": "The ACPI _PRS resource type was expected to be an IRQ type and was not.",
   "label": "KlogAcpiPciLinkPrsIrq"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "_CRS resource type 0x%x isn't an IRQ",
   "advice": "The ACPI _CRS resource type was expected to be an IRQ type and was not.",
   "label": "KlogAcpiPciLinkCrsIrq"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unable to read status",
   "advice": "A query of _STA to get the bus status failed and the current link status is unknown.",
   "label": "KlogAcpiPciLinkSta"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "_CRS returned 0",
   "advice": "The query of the bus status failed because the _CRS controlled returned IRQ 0, which was not expected.",
   "label": "KlogAcpiPciLinkCrsIrqZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid Resource_type",
   "advice": "A PCI link set failed because the link IRQ resource type is invalid.",
   "label": "KlogAcpiPciLinkIrqResourceInvalid"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unable to set IRQ for",
   "advice": "An attempt to enabled the link device failed.",
   "label": "KlogAcpiPciLinkFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid link device",
   "advice": "Unable to allocate an IRQ failed because the link device is invalid.",
   "label": "KlogAcpiPciLinkDeviceInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid link context",
   "advice": "Unable to allocate an IRQ failed because the link context was invalid (NULL).",
   "label": "KlogAcpiPciLinkContextNull"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*Invalid index",
   "advice": "Support for multiple index IRQ entries per link device is not yet implemented.",
   "label": "KlogAcpiPciLinkMultipleIrqEntries"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Link active IRQ is 0",
   "advice": "Unable to allocate an IRQ failed because the active IRQ is 0, which is wrong.",
   "label": "KlogAcpiPciLinkActiveIrqZero"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Link isn't initialized",
   "advice": "An attempt to free the IRQ of a link failed because the link was not initialized.",
   "label": "KlogAcpiPciLinkNotInitialized"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Evaluating processor object",
   "advice": "An error occurred evaluating the ACPI Processor() object, ACPI CPU control for this CPU broken.",
   "label": "KlogAcpiProcessorFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Evaluating processor _UID",
   "advice": "An error occurred evaluating an ACPI CPU _UID, ACPI CPU control for this CPU is broken.",
   "label": "KlogAcpiProcessorBadUid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid PBLK length",
   "advice": "The Processor Register Block data is not the expected size, ACPI control of this CPU will not occur.",
   "label": "KlogAcpiProcessorPblkBad"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Processor driver could not be attached",
   "advice": "An attempt to add a processor to the system failed in acpi_processor_add(), the processor driver's .probe failed calling device_attach(). The CPU cannot be added to the system under ACPI control.",
   "label": "KlogAcpiProcessorNotAttached"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _PSS data",
   "advice": "Failed to get ACPI performance states from the _PSS contol, buffer was either NULL or not an ACPI package.",
   "label": "KlogAcpiPssFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid BIOS _PSS frequency found for processor",
   "advice": "CPU frequency in MHz as supplied by _PSS control cannot be stored in a 32 bit unsigned integer, overflow error.",
   "label": "KlogAcpiPssFreqTooBig"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "No valid BIOS _PSS frequency found for processor",
   "advice": "One of the CPUs did not have a valid _PSS frequency defined. Cannot fetch _PSS levels for this CPU.",
   "label": "KlogAcpiPssNotFound"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _PSD data",
   "advice": "The ACPI _PSD control returned a pointer that was NULL or not an ACPI package or did not have 1 item in the package or the item could not be fetched out of the package. P-State dependencies cannot be evaluated, machine may perform sub-optimally.",
   "label": "KlogAcpiPsdBadData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unknown _PSD:num_entries",
   "advice": "The number of _PSD entries should be 5 but a different count was returned. The P-State dependencies cannot be evaluated, machine may perform sub-optimally.",
   "label": "KlogAcpiPsdBadCount"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unknown _PSD:revision",
   "advice": "The _PSD revision should be 0 but a different version was returned. P-State dependencies cannot be evaluated, machine may perform sub-optimally.",
   "label": "KlogAcpiPsdBadRevision"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _PSD:coord_type",
   "advice": "The _PSD coordination type was invalid, it should be SW_ALL, SW_ANY or HW_ALL. P-State dependencies cannot be evaluated, machine may perform sub-optimally.",
   "label": "KlogAcpiPsdBadCoordType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Failed to switch the brightness",
   "advice": "The ACPI video brightness for the LCD could not be set because _BCM failed.",
   "label": "KlogAcpiVideoBcmFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _DOD data in element",
   "advice": "The ACPI _DOD control returned an element that was not an ACPI integer as expected. This element will be ignored, which could lead to reduced functionality.",
   "label": "KlogAcpiVideoDodFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _DDC data",
   "advice": "The ACPI _DDC control is returning either a NULL buffer pointer or data that is not an ACPI buffer. The Extended Display Identification Data (EDID) structure that represents the display output device could not be fetched. This may affect video output.",
   "label": "KlogAcpiVideoDdcFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _BCL data",
   "advice": "The ACPI _BCL control is returning either a NULL buffer pointer or data that is not an ACPI package. LCD brightness level queries will not work.",
   "label": "KlogAcpiVideoBclFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Oops, 'acpi_handle' corrupt",
   "advice": "Failed to unbind a device, the ACPI handle was corrupt.",
   "label": "KlogAcpiHandleCorrupt"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Can't use platform_notify",
   "advice": "Cannot add the ACPI platform notifiers, they are already registered. This should not happen.",
   "label": "KlogAcpiPlatformNotify"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "memory_hp:Error in acpi_memory_enable_device",
   "advice": "Adding a hotplug memory device failed because.",
   "label": "KlogAcpiHotPlugAddMemDeviceFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_INFO",
   "pattern": "memory_hp:Disable memory device",
   "advice": "An ACPI notify eject request occurred to disable a memory device.",
   "label": "KlogAcpiHotPlugNotifyDisableOkay"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "memory_hp:Driver Data is NULL",
   "advice": "An ACPI notify eject request failed because the device data is NULL.",
   "label": "KlogAcpiHotPlugNotifyEjectDataNull"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Device doesn't exist",
   "advice": "An ACPI notify eject request failed because the device does not exist.",
   "label": "KlogAcpiHotPlugNotifyEjectDeviceNotExist"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "memory_hp:Cannot enable memory device",
   "advice": "Memory device notify failed because it could not enabled the memory device.",
   "label": "KlogAcpiHotPlugEnableFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "memory_hp:Cannot find driver data",
   "advice": "Memory device notify failed because it could not find the relevant driver data for this device.",
   "label": "KlogAcpiHotPlugDeviceNotify"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "memory_hp:add_memory failed",
   "advice": "Failed to add memory device, add_memory() failed for some reason.",
   "label": "KlogAcpiHotPlugAddMemoryFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "memory_hp:get_device_resources failed",
   "advice": "The devices resources could not be determined from the relevant ACPI _CRS control and so the memory device could not be enabled.",
   "label": "KlogAcpiHotPlugCrsFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Fatal opcode executed",
   "advice": "An ACPI AML fatal opcode was executed and the kernel has trapped this signal. It could be because of faulty control method code.",
   "label": "KlogAcpiFatalOpcodeSignal"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Call to queue_work() failed.",
   "advice": "Failed to queue up AML exec work on CPU 0. This results in ACPI control code not being executed which could lead to unexpected behaviour.",
   "label": "KlogAcpiQueueWorkFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "acpi_os_get_timer() TBD",
   "advice": "Support for the 64 bit ACPI AML timer operand is not implemented, this will be emulated and may affect AML code that relies on accurate timers.",
   "label": "KlogAcpiGetTimerNotImplemented"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "SCI .* allocation failed",
   "advice": "Failed to install an ACPI SCI interrupt handler because the the IRQ allocation failed.",
   "label": "KlogAcpiSciIrqAllocError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "SCI .*ACPI GSI .* not registered",
   "advice": "Failed to install an ACPI SCI interrupt handler because the Global System Interrupt (GSI) is not registered.",
   "label": "KlogAcpiSciGsiError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Cannot map memory that high",
   "advice": "Cannot map an ACPI physical address above the 32 bit 4GB limit, this could lead to broken functionality.",
   "label": "KlogAcpiMap4GbLimit"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "System description tables not found",
   "advice": "The EFI ACPI20 or ACPI RSDP pointers were invalid, so the kernel cannot find any of the ACPI tables.  ACPI support will be disabled.",
   "label": "KlogAcpiEfiRsdpError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Invalid EFI RTC value: write of .* to EFI RTC failed",
   "advice": "Failed to update the EFI Real Time Clock (RTC), the provided time was not a valid time and so the EFI RTC was not updated.",
   "label": "KlogAcpiEfiRtcWriteFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "acpi_memory_enable_device() error",
   "advice": "ACPI memory hotplug failed to add an ACPI memory device to the systen. This error can occur if the memory block has already been used by the kernel or if the ACPI memory bind failed.",
   "label": "KlogAcpiMemEnableDevice"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Vendor .* System .* Revision .* has a known ACPI BIOS problem",
   "advice": "The kernel has recognised that this particular version of the firmware has known ACPI issues and so ACPI support will be disabled. Reduced functionality will occur.",
   "label": "KlogAcpiBlackListed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Unable to register for device notifications",
   "advice": "The ACPI device notify handlers failed to be installed and so ACPI support with be disabled.",
   "label": "KlogAcpiNotifyHandlerInstallFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Unable to initialize ACPI objects",
   "advice": "The ACPI objects failed to initialize and so ACPI support with be disabled.",
   "label": "KlogAcpiObjectsFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Unable to start the ACPI Interpreter",
   "advice": "The ACPI interpreter failed to start up correctly and so ACPI support with be disabled.",
   "label": "KlogAcpiInterpreterFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Unable to enable ACPI",
   "advice": "The ACPI subsystem failed to be enabled and so ACPI support with be disabled.",
   "label": "KlogAcpiEnableFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Unable to load the System Description Tables",
   "advice": "The ACPI driver was unabled to load the ACPI tables and so ACPI support will be disabled.",
   "label": "KlogAcpiLoadFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Unable to initialize the ACPI Interpreter",
   "advice": "The ACPI interpreter could not be intialized and so ACPI support will be disabled.",
   "label": "KlogAcpiInitFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Unable to reallocate ACPI tables",
   "advice": "The kernel count not reallocate the ACPI tables into memory from firmware and so ACPI support will be disabled.",
   "label": "KlogAcpiReallocateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "can't evaluate _SEG",
   "advice": "The _SEG ACPI control could not be evaluated. This will stop certain PCI root bridges from being added and enabled on the computer.",
   "label": "KlogAcpiSegFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "can't evaluate _BBN",
   "advice": "The _BBN ACPI control could not be evaluated. This will stop certain PCI root bridges from being added and enabled on the computer.",
   "label": "KlogAcpiSegFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Bus .*:.* not present in PCI namespace",
   "advice": "The bus cound not be found in the PCI namespace. This will stop certain PCI root bridges from being added and enabled on the computer.",
   "label": "KlogAcpiPciScanFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "_DSW execution failed",
   "advice": "The ACPI control _DSW (Device Sleep Wake) failed to execute, this may impact on the ability to enable or disable the wake capabilities of a device in the computer.",
   "label": "KlogAcpiDswFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "_PSW execution failed",
   "advice": "The ACPI control _PSW (Power State Wake) failed to execute, this may impact on the ability to enable or disable the wake capabilities of a device in the computer.",
   "label": "KlogAcpiPswFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Transition power state",
   "advice": "Failed to power on or shutdown a wakeup device using _PSW or _DSW control methods.",
   "label": "KlogAcpiSuspend"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Fail in evaluating the _REG object of EC device",
   "advice": "The _REG object for the Embedded Controller Device could not be evaluated, however the kernel will ignore this and try to install the handler for the Embedded Controller.",
   "label": "KlogAcpiEcBadReg"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unable to undock",
   "advice": "An undock event was requested but the machine still seems to be docked.",
   "label": "KlogAcpiDockCannotUndock"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unable to dock",
   "advice": "A dock notify event was handled but the machine still seems to be undocked.",
   "label": "KlogAcpiDockCannotDoct"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unknown dock event",
   "advice": "A dock notify event was handled, but the type of notify event was not recognised.",
   "label": "KlogAcpiDockEvent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": ".* encountered error .*",
   "advice": "An error occurred when trying to add a new dock station device.",
   "label": "KlogAcpiDockAdd"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "More than one Lid device found",
   "advice": "Failed to add a Lid device because one already exists.  The kernel does not support more than one Lid device.",
   "label": "KlogAcpiLidMany"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Unsupported hid",
   "advice": "The Lid Hardware ID (HID) is one that the kernel does not recognise and so the Lid device was not added to the system. This can explain why the Lid does not work.",
   "label": "KlogAcpiLidBadHid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "device is NULL",
   "advice": "The kernel count not add a container because the device associated with this was NULL, which is unexexpected.",
   "label": "KlogAcpiContainer"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "wakeup header does not match",
   "advice": "The ACPI suspend wakeup header did not contain the expected header value so the kernel had to abort the suspend. This can happen if the data is corrupted.",
   "label": "KlogAcpiSuspendHeader"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "not enough elements in _CST",
   "advice": "_CST returned either a NULL buffer or a type that wasn't an ACPI package or less than 2 elements in the package. The kernel could not evaluate the CPU supported C states supported, meaning that the machine will not run optimally.",
   "label": "KlogAcpiCstElements"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "count given by _CST is not valid",
   "advice": "_CST returned an invalid number of elements, the package a different number of C states to the number of C states that _CST reported. The kernel could not evaluate the CPU supported C states supported, meaning that the machine will not run optimally.",
   "label": "KlogAcpiCstCount"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "No return object",
   "advice": "An ACPI evaluate for a reference returned a buffer of zero length or a NULL buffer pointer.",
   "label": "KlogAcpiEvalReferenceBadBuffer"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Expecting a [Package], found type",
   "advice": "An ACPI evaluate for a reference did not return a ACPI package as expected.",
   "label": "KlogAcpiEvalReferenceNotPackage"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "[Package] has zero elements",
   "advice": "An ACPI evaluate for a reference returned an illeage package of zero elements.",
   "label": "KlogAcpiEvalReferencePackageZeroElements"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Expecting a [Reference] package element, found type",
   "advice": "An ACPI evaluate for a reference returned contained an element that was not a reference type.",
   "label": "KlogAcpiEvalReferencePackageElementType"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "error obtaining _EC",
   "advice": "The ACPI Embedded Controller Offset Query Control Method _EC failed to evaluate. It is either missing or broken and means the kernel cound not add a SMBUS host controller.",
   "label": "KlogAcpiEcFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "host controller is not configured",
   "advice": "The kernel count not issue a SMBUS transaction because the host controller was not configured. See acpi_smbus_transaction()",
   "label": "KlogSmbusHostController"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Error attaching device data",
   "advice": "The kernel could not register a thermal zone because acpi_attach_data() failed for some reason. The machine may not be able to optimally cool itself and may have overheating issues because of this error.",
   "label": "KlogAcpiThermZoneAttachFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _TSS data: freq is zero",
   "advice": "The _TSS has returned a zero fequency setting in one or more of the package elements.",
   "label": "KlogAcpiTssZeroFrequency"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _TSS data",
   "advice": "The _TSS has returned a NULL data pointer or data which isn't an ACPI package.",
   "label": "KlogAcpiTssBadData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unknown _TSD:num_entries",
   "advice": "The number of entries in the throlling domain information was not 5.",
   "label": "KlogAcpiTsdIllegalNumEntries"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unknown _TSD:revision",
   "advice": "The expected TSD revision was not 0.",
   "label": "KlogAcpiTsdBadRevision"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "HARDWARE addr space,NOT supported yet",
   "advice": "The CPU does not seem to support the MSR_IA32_THERM_CONTROL MSR.",
   "label": "KlogAcpiUnsupportedThermControlMsr"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Unknown addr space",
   "advice": "Could not read the hardware specific throttling status, the status register space ID was not a system I/O space or a fixed hardware space.",
   "label": "KlogAcpiThrottleStatusBadRead"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _TSD data",
   "advice": "The _TSD has returned data which isn't valid, either a NULL data pointer or data which isn't an ACPI package has been returned.",
   "label": "KlogAcpiTsdBadData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _PTC control register",
   "advice": "The _PTC control register bit widths or bit offsets are incorrect.",
   "label": "KlogAcpiPtcControlRegisterInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _PTC status register",
   "advice": "The _PTC status register bit widths or bit offsets are incorrect.",
   "label": "KlogAcpiPtcStatusRegisterInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _PTC data (status_register)",
   "advice": "The _PTC status register data (element 1 of the package) was either NULL or too small.",
   "label": "KlogAcpiPtcDataStatusRegister"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _PTC data (control_register)",
   "advice": "The _PTC control register data (element 0 of the package) was either NULL or too small.",
   "label": "KlogAcpiPtcDataControlRegister"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Invalid _PTC data",
   "advice": "_PTC did not return a package of two elements, expected a two element package containing bufffers for the control and status register.",
   "label": "KlogAcpiPtcDataBad"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Failed to create sysfs link 'thermal_cooling'",
   "advice": "sysfs_create_link() failed to create the thermal 'thermal_cooling' sysfs entry.",
   "label": "KlogAcpiThermalThermalCoolingSysfs"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Failed to create sysfs link 'device'",
   "advice": "sysfs_create_link() failed to create the thermal 'device' sysfs entry.",
   "label": "KlogAcpiThemalDeviceSysfs"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Setting initial power state",
   "advice": "The call to acpi_bus_update_power() in acpi_fan_add() failed while adding a new fan device.",
   "label": "KlogAcpiFanAddFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "EC.*input buffer is not empty, aborting transaction",
   "advice": "The ACPI Embedded Controller (EC) driver attempted to perform a read or write transaction but had to abort because the EC was still busy and the input buffer was not emptied within 500ms.  Normally this indicates an EC firmware fault.  One can try increasing the delay using the acpi.ec_delay kernel parameter or writing to /sys/module/acpi/parameters/ec_delay - however this generally does not help much if the EC firmware is buggy.",
   "label": "KlogAcpiEcInputBufferIsNotEmpty"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_INFO",
   "pattern": "ENERGY_PERF_BIAS.*Set to 'normal'.* was 'performance'",
   "advice": "This is not exactly a failure but a warning from the kernel. The MSR_IA32_ENERGY_PERF_BIAS was initialized and defaulted to a high performance bias setting. The kernel has detected this and changed it down to a 'normal' bias setting.",
   "label": "KlogEnergyPerfBiasSetToNormal"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "pnp.*can't evaluate _CRS: 12311",
   "advice": "The _CRS object could not be evaluated because an invalid resource type has been returned. This can lead to misconfigured PNP hardware and may render a system unbootable.",
   "label": "KlogPnpCrsInvalidResourceType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "pnp.*can't evaluate _CRS:",
   "advice": "The _CRS object could not be evaluated, the error code is an ACPI error return code (see include/acpi/acexecp.h in the linux source, this is composed of bottom 12 bits of an error number and upper 4 bits of an AE_CODE_* code. Typically, _CRS evaluation errors can lead to misconfigured PNP hardware and may render a system unbootable.",
   "label": "KlogPnpCrsCannotEvaluate"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "dell_wmi:.*Received unknown WMI event",
   "advice": "The Dell WMI driver has received an unknown WMI event. The driver should handle this new event or the firmware is reporting an incorrect and unknown event.",
   "label": "KlogDellWmiReceivedUnknownWMIEvent"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "dell_wmi:.*bad event status 0x",
   "advice": "The Dell WMI driver has received a bad event status. This should be investigated further.",
   "label": "KlogDellWmiBadEventStatus"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "asus_wmi:.*Unknown key.*pressed",
   "advice": "The ASUS WMI driver has received an unknown key event. The driver should handle this new key event or the firmware is reporting an incorrect and unknown event.",
   "label": "KlogAsusWmiUnknownKeypressed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "hp_wmi:.*bad event status 0x",
   "advice": "The HP WMI driver has received a bad event status. This should be investigated further.",
   "label": "KlogHpWmiBadEventStatus"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "hp_wmi:.*Unknown response received",
   "advice": "The HP WMI driver has received a return object that was not of type ACPI_BUFFER. The driver needs to be updated to handle this new return type or there is a bug in the WMI mechanism on this machine.",
   "label": "KlogHpWmiUnknownResponseReceived"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "hp_wmi:.*Unknown buffer length",
   "advice": "The HP WMI driver has received a return buffer that was not the expected size of 8 or 16 bytes. This is probably a bug in the WMI mechanism on this machine.",
   "label": "KlogHpWmiUnknownBufferLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "hp_wmi:.*Unknown key code - 0x",
   "advice": "The HP WMI driver has received a key code that it does not recognise. The driver needs to be updated to handle this new key code.",
   "label": "KlogHpWmiUnknownKeyCode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "hp_wmi:.*Unknown event_id",
   "advice": "The HP WMI driver has received an event ID that it does not recognise. The driver needs to be updated to handle this new event ID.",
   "label": "KlogHpWmiUnknownEventId"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "msi_wmi:.*Unknown key pressed",
   "advice": "The MSI WMI driver has received a key code that it does not recognise. The driver needs to be updated to handle this new key code.",
   "label": "KlogMsiWmiUnknownKeyPressed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*Handling Garbled _PRT entry",
   "advice": "BIOS has a garbled _PRT entry; source_name and source_index swapped.",
   "label": "KlogAcpiHandlingGarbledPrtEntry"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "Invalid _PCT data",
   "advice": "The ACPI _PCT data is invalid.",
   "label": "KlogInvalidPctData"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*ACPI path has too many parent prefixes",
   "advice": "A path to an ACPI obejct has too many ^ parent prefixes and references passed the top of the root node. Please check AML for all ^ prefixed ACPI path names.",
   "label": "KlogAcpiPathTooManyParentPrefixes"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "A valid RSDP was not found",
   "advice": "An ACPI compatible system must provide an RSDP (Root System Description Pointer). This structure provides the physical address of the RSDT and XSDT. Since this could not be found, the ACPI driver has had to disable ACPI support.",
   "label": "KlogAcpiValidRsdpNotFound"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "ACPI Error.*Cannot release Mutex",
   "advice": "Attempted to release of a Mutex that was not previous acquired. This needs fixing as it could lead to race conditions when operating on a resource that needs to be proteced by a Mutex.",
   "label": "KlogAcpiCannotReleaseMutex"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Could not disable .* event",
   "advice": "",
   "label": "KlogAcpiCouldNotDisableEvent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Could not enable .* event",
   "advice": "",
   "label": "KlogAcpiCouldNotEnableEvent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Namespace lookup failure, AE_ALREADY_EXISTS",
   "advice": "",
   "label": "KlogAcpiNamespaceLookupFailure"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "ACPI Error.*_SB_._OSC.*AE_AML_BUFFER_LIMIT",
   "advice": "Section 6.2.10.2 of V4.0a of the ACPI specification states that the _OSC Method should be passed an 8 byte buffer of 2 x 32 DWORDs, however it appears that the method is possibly trying to access data outside this buffer. This is a bug in the _OSC method.",
   "label": "KlogAcpiSbOscAeAmlBufferLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": ".*pci.*ACPI _OSC request failed.*returned control mask",
   "advice": "The _OSC method evaluation failed, which will result in disabling PCIe functionality, for example, the Linux kernel has to disable Active State Power Management (ASPM) which means that PCIe power management is not optimally configured.",
   "label": "KlogPciAcpiOscRequestFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "_OSC invalid UUID",
   "advice": "The _OSC method indicates it has been passed an invalid UUID, see section 6.2.10 _OSC (Operating System Capabilities) of the ACPI specification for more details.  Note that it has been observed on some systems that this error is returned because the _OSC has evaluated incorrectly and it returns with an incorrect error setting the OSC invalid UUID error bit.",
   "label": "KlogOscInvalidUuid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "_OSC invalid revision",
   "advice": "The _OSC method indicates it has been passed an invalid revision number, see section 6.2.10 _OSC (Operating System Capabilities) of the ACPI specification for more details.  Note that the revision level is specific to the given UUID.",
   "label": "KlogOscInvalidRevision"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "_OSC request failed",
   "advice": "The _OSC method evaluation failed for some unknown reason. This could be that the data passed to it was incorrect or that the method itself is broken. See section 6.2.10 _OSC (Operating System Capabilities) of the ACPI specification for more details.",
   "label": "KlogOscRequestFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "_OSC request failed",
   "advice": "The _OSC method evaluation failed for some unknown reason. This could be that the data passed to it was incorrect or that the method itself is broken. See section 6.2.10 _OSC (Operating System Capabilities) of the ACPI specification for more details.",
   "label": "KlogOscRequestFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "ACPI Error.*Field.*exceeds Buffer",
   "advice": "The field exceeds the allocated buffer size. This can lead to unexpected results when fetching data outside this region.",
   "label": "KlogAcpiFieldexceedsBuffer"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "ACPI Error.*Illegal I\/O port address\/length above 64K",
   "advice": "A port address or length has exceeded the maximum allowed 64K address limit. This will lead to unpredicable errors.",
   "label": "KlogAcpiIllegalIOAbove64K"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Incorrect return type",
   "advice": "An ACPI Method has returned an unexpected and incorrect return type.",
   "label": "KlogAcpiIncorrectReturnType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Needed .*\\[Buffer\/String\/Package\\], found \\[Integer\\]",
   "advice": "An ACPI Method has returned an Integer type when a Buffer, String or Package was expected.",
   "label": "KlogAcpiNeededBufferOrStringOrPackage"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Needed .*\\[Reference\\], found \\[Device\\]",
   "advice": "An ACPI Method has returned an Device type when a Reference type was expected.",
   "label": "KlogAcpiNeededReference"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*No handler for Region.*SystemCMOS",
   "advice": "An attempt to dispatch an address space or operation region access to CMOS memory has failed because the Linux kernel does not yet have a CMOS handler.  This may have little or no detrimental effect, however it is worth examining the AML to see what kind of access is occurring to see if the firmware really requires CMOS access.  For example, recent firmware may implement Peak Shift, which requires access CMOS memory and this can trigger this error.",
   "label": "KlogAcpiNoHandlerForRegion"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "No handler for Region",
   "advice": "ACPI attempted to read or write to a region however the ACPI driver does not have a handler implemented for this particular region space.  The read/write will fail and undefined behaviour will occur.",
   "label": "KlogAcpiNoHandlerForRegion"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Region SystemCMOS.* has no handler",
   "advice": "An attempt to read or write a single field to a CMOS Operation Region has failed because the Linux kernel does not yet have a CMOS handler.  This may have little or no detrimental effect, however it is worth examining the AML to see what kind of access is occurring to see if the firmware really requires CMOS access.  For example, recent firmware may implement Peak Shift, which requires access CMOS memory and this can trigger this error.",
   "label": "KlogAcpiRegionHasNoHandler"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Region .* has no handler",
   "advice": "",
   "label": "KlogAcpiRegionHasNoHandler"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Missing expected return value",
   "advice": "The ACPI Method did not return a value and was expected too. This is a bug and needs fixing.",
   "label": "KlogAcpiMissingExpectedReturnValue"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Package List length.*larger than.*truncated",
   "advice": "A Method has returned a Package List that was larger than expected.",
   "label": "KlogAcpiPackageListLargerThanExpected"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "ACPI Error.*Found unknown opcode",
   "advice": "An illegal AML opcode has been found and is ignored. This indicates either badly compiled code or opcode corruption in the DSDT or SSDT tables or a bug in the ACPI execution engine. Recommend disassembing using iasl to find any offending code.",
   "label": "KlogAcpiFoundUnknownOpcode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "ACPI Warning.*Detected an unsupported executable opcode",
   "advice": "An illegal AML opcode has been found and is ignored. This indicates either badly compiled code or opcode corruption in the DSDT or SSDT tables or a bug in the ACPI execution engine. Recommend disassembing using iasl to find any offending code.",
   "label": "KlogAcpiDetectedUnsupportedOpCode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "bios32_service.*not present",
   "advice": "The BIOS has found a BIOS32 Service Directory but the BIOS has returned error 0x80 on calling the service, which indicates that the requested service has not been implemented in the firmware.",
   "label": "KlogBios32ServiceNotPresent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "bios32_service.*BIOS bug",
   "advice": "The BIOS has found a BIOS32 Service Directory but the BIOS has returned an error on calling the service, which is unexpected and usually means the firmware is broken.",
   "label": "KlogBios32ServiceBiosBug"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PCI: Error.*when fetching IRQ routing table",
   "advice": "The BIOS has been interrogated for the PCI IRQ routing table but the BIOS returned an error.",
   "label": "KlogPciFetchingIRQRoutingTable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "ACPI Error.*Denied AML access to port",
   "advice": "AML code was accessing an I/O port that was banned from accesses. Ports 0x20-0x21 (PIC0), 0xa0-0xa1 (PIC1), 0x4d0-0x4d1 (ELCR) are always banned. For _OSI() greater or equal to 'Windows 2001' (Windows XP) ports 0x00-0x0f (DMA), 0x40-0x43 (PIT1), 0x48-0x4b (PIT2), 0x70-0x71 (RTC), 0x81-0x83 (DMA1), 0x87 (DMA1L), 0x89-0x8b (DMA2), 0x8f (DMA2L), 0x90-0x91 (ARBC), 0x93-0x94 (SETUP), 0x96-0x97 (POS), 0xc0-0xdf (ISA DMA) and 0xcf8-0xcff (PCI config) are banned.  Since the AML code has been banned from accessing these ports you will get undefined behaviour and the AML code should be fixed.",
   "label": "KlogAcpiDeniedAmlAccessToPort"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Method parse\/execution failed.*AE_AML_NO_RETURN_VALUE",
   "advice": "The ACPI Method was expected to return a value and did not.",
   "label": "KlogAcpiMethodNoReturnValue"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Method parse/execution failed.*EC.*AE_TIME",
   "advice": "The ACPI driver encountered an error executing some ACPI AML code which originated from the Embedded Controller (EC) timing out while waiting for a transaction to complete. This could indicate that either EC interrupts are being disabled or that the EC has temporarily gone offline or locked up, so this could be a kernel error or more probably a bug in the EC firmware.  See the kernel driver drivers/acpi/ec.c.  One can increase EC timeouts using the kernel parameter ec_delay to specify the timeout in milliseconds, the default is 500.",
   "label": "KlogAcpiEcTimeout"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Method parse/execution failed.*AE_TIME",
   "advice": "The ACPI driver encountered an error executing some ACPI AML code which originated from a device timing out.",
   "label": "KlogAcpiTimeout"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_ALREADY_EXISTS",
   "advice": "",
   "label": "KlogAcpiObjectAlreadyExists"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_INVALID_TABLE_LENGTH",
   "advice": "The ACPI Method returned a table of the incorrect length. This can lead to unexepected results.",
   "label": "KlogAcpiInvalidTableLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*_SRS.*AE_AML_BUFFER_LIMIT",
   "advice": "Method failed: ResourceSourceIndex is present but ResourceSource is not. This is a common issue from a particular BIOS vendor, the _SRS (Set Resource Settings) optional control takes a byte stream argument that specifies a new resource allocation for a device. The resource descriptors in the byte stream argument must be specified exactly as listed by _CRS.  However, in this case _SRS has been passed a byte stream that is too short and attempted to access bytes outside the buffer causing this error. This is a firmware bug that needs to be fixed.",
   "label": "KlogAcpiBufferLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_AML_BUFFER_LIMIT",
   "advice": "Generally this error occurs because of access outside of a buffer.  This occurs for several reasons: a) A field does not fit within the current length of a buffer, b) an ACPI table load did not fit into a buffer, c) An attempt to convert a buffer into an integer failed because the buffer was zero sized, d) a SMBus/IPMI/GenericSerialBus write failed because the buffer was too small, e) An index into a buffer was too long and fell outside the buffer.",
   "label": "KlogAcpiBufferLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_INFO",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*_PTS.*AE_NOT_EXIST",
   "advice": "The kernel has attempted to execute the _PTS (Prepare to Suspend) control but it has not been implemented on this platform.  Section 6.1 of the ACPI specification states: 'The _PTS control method provides the BIOS a mechanism for performing some housekeeping, such as writing the sleep type value to the embedded controller, before entering the system sleeping state'.  Hence _PTS is provided for the firmware to do housekeeping and therefore does not appear to be mandatory.  In this case, the platform seems to have omitted _PTS because it may not need it.  Unfortunately the kernel complains about this not existing. This is most probably not an error.",
   "label": "KlogAcpiObjectDoesNotExist"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_NOT_EXIST",
   "advice": "The ACPI interpreter failed to execute or parse some AML because a object or control did not exist.  This normally occurs because of buggy firmware and may lead to unexpected behaviour or loss of functionality.",
   "label": "KlogAcpiObjectDoesNotExist"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_NOT_FOUND",
   "advice": "",
   "label": "KlogAcpiObjectNotFound"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_LIMIT",
   "advice": "",
   "label": "KlogAcpiExecLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_AML_OPERAND_TYPE",
   "advice": "",
   "label": "KlogAcpiOperandType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_TIME",
   "advice": "",
   "label": "KlogAcpiTimeOut"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_AML_PACKAGE_LIMIT",
   "advice": "",
   "label": "KlogAcpiPackageLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_OWNER_ID_LIMIT",
   "advice": "Method failed to allocate owner ID.",
   "label": "KlogAcpiOwnerIdLimit"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Method (execution|parse\/execution) failed.*AE_AML_MUTEX_NOT_ACQUIRED",
   "advice": "A Mutex acquire failed, which could possibly indicate that it was previously acquired and not released, or a race has occurred. Some AML code fails to miss Mutex acquire failures, so it is a good idea to verify all Mutex Acquires using the syntaxcheck test.",
   "label": "KlogAcpiMutexNotAcquired"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Method parse/execution failed",
   "advice": "The ACPI driver encountered a parse or execution error on some ACPI AML code. This is unexepcted and normally indicates that there is a bug in the compiled AML code.  It could be a programming fault or an AML compiler issue.  See acpi_ps_parse_aml().",
   "label": "KlogAcpiParseExecAmlFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*SMBus or IPMI write requires Buffer of",
   "advice": "An incorrect SMBus or IPMI write buffer size was used.",
   "label": "KlogAcpiIncorrectWriteBufferSize"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI (Warning|Error).*Evaluating .* failed",
   "advice": "Executing the ACPI Method leaded in an execution failure. This needs investigating.",
   "label": "KlogAcpiEvaluationFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Optional field.*has zero address or length",
   "advice": "An ACPI table contains Generic Address Structure that has an address that is incorrectly set to zero, or a zero length. This needs to be fixed. ",
   "label": "KlogAcpiOptionalFieldZeroAddressOrLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI (Warning|Error).*two DSDT tables",
   "advice": "The FADT table contains a mismatch between the 32 bit pointer (DSDT) and 64 bit pointer (X_DSDT) pointer to the FACS table.  Section 5.2.9 of version 4.0a of the ACPI specification states that X_DSDT should be zero if DSDT is defined, or DSDT should be zero if X_DSDT is zero. With two different pointers defined, the kernel has to make a choice, and opts for the 32 bit pointer. Because these pointers are different, it suggests either one of them is incorrect, or different 32 bit and 64 bit DSDT tables are present in your system, which is NOT complaint with the ACPI specification.  The kernel has to make a choice and opts for the 32 bit DSDT.",
   "label": "KlogAcpiTwoDsdt"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI (Warning|Error).*two FACS tables",
   "advice": "The FADT table contains a mismatch between the 32 bit pointer (FIRMWARE_CTRL) and 64 bit pointer (X_FIRMWARE_CTRL) pointer to the FACS table.  Section 5.2.9 of version 4.0a of the ACPI specification states that X_FIRMWARE_CTRL should be zero if FIRMWARE_CTRL is defined, or FIRMWARE_CTRL should be zero if X_FIRMWARE_CTRL is zero. With two different pointers defined, the kernel has to make a choice, and opts for the 32 bit pointer. Because these pointers are different, it suggests either one of them is incorrect, or different 32 bit and 64 bit FACS tables are present in your system, which is NOT complaint with the ACPI specification.  The kernel has to make a choice and opts for the 32 bit FIRMWARE_CTRL.",
   "label": "KlogAcpiTwoFacs"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "32/64X address mismatch in.*, using 32",
   "advice": "The FADT table contains a mismatch between a 32 bit pointer and a 64 bit Generic Address pointer. Because these pointers are different, it suggests either one of them is incorrect.  If a non-null 32 bit pointer exists, then the kernel will opt for this in preference to the 64 bit pointer even though this is not in accordance to the ACPI specification.",
   "label": "KlogAcpi32Bit64BitAddressMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI (Warning|Error).*32\/64.*(length|address) mismatch in.*tbfadt",
   "advice": "The FADT table contains Generic Address Structure that has a mismatch between the 32 bit and 64 bit versions of an address. This should be fixed so there are no mismatches. ",
   "label": "KlogAcpi32Bit64BitAddressMismatchInFadt"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI (Warning|Error).*32\/64.*(length|address) mismatch in",
   "advice": "A table contains Generic Address Structure that has a mismatch between the 32 bit and 64 bit versions of an address. This should be fixed so there are no mismatches. ",
   "label": "KlogAcpi32Bit64BitAddressMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Return Package type mismatch",
   "advice": "ACPI AML interpreter executed a Method that returned a package with incorrectly typed data. The offending method needs to be fixed.",
   "label": "KlogAcpiReturnPackageTypeMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Return Package has no elements",
   "advice": "ACPI AML interpreter executed a Method that returned a package with no elements inside it. This is most probably a bug in the Method and needs to be fixed.",
   "label": "KlogAcpiReturnPackageZeroElements"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Return Package is too small",
   "advice": "ACPI AML interpreter executed a Method that returned a package with too few elements inside it. This is most probably a bug in the Method and needs to be fixed.",
   "label": "KlogAcpiReturnPackageTooSmall"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "ACPI Warning.*Incorrect checksum in table",
   "advice": "The ACPI table listed above has an incorrect checksum, this could be a BIOS bug or due to table corruption.",
   "label": "KlogAcpiIncorrectTableChecksum"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*_BQC returned an invalid level",
   "advice": "Method _BQC (Brightness Query Current) returned an invalid display brightness level.",
   "label": "KlogAcpiBqcReturnedInvalidLevel"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Could not enable fixed event",
   "advice": "",
   "label": "KlogAcpiCannotEnableFixedEvent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Return type mismatch",
   "advice": "The ACPI Method returned an incorrect type, this should be fixed.",
   "label": "KlogAcpiReturnTypeMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Parameter count mismatch",
   "advice": "The ACPI Method was executing with a different number of parameters than the Method expected. This should be fixed.",
   "label": "KlogAcpiParameterCountMistmatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Insufficient arguments",
   "advice": "The ACPI Method has not enough arguments as expected. This should be fixed.",
   "label": "KlogAcpiInsufficientArguments"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Package has no elements",
   "advice": "The ACPI Method returned a package with no elements in it, and some were exepected.This should be fixed.",
   "label": "KlogAcpiPackageHasNoElements"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Converted Buffer to expected String",
   "advice": "Method returned a Buffer type instead of a String type and ACPI driver automatically converted it to a String.  It is worth fixing this in the DSDT or SSDT even if the kernel fixes it at run time.",
   "label": "KlogAcpiConvertedBufferToString"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Return Package type mistmatch at index",
   "advice": "The ACPI Method returned a package that contained data of the incorrect data type. This data type needs fixing.",
   "label": "KlogAcpiReturnPackageTypeMismatch"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Invalid length for.*fadt",
   "advice": "This item in the FADT is the incorrect length. Should be corrected.",
   "label": "KlogAcpiFadtInvalidLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_INFO",
   "pattern": "ACPI Warning.*FADT .*revision 5.* is longer than ACPI 2.*0 version",
   "advice": "The kernel has not supported ACPI version 5.0, it truncated the FADT back to ACPI2.0 size and ignored the extra ACPI5.0 settings.",
   "label": "KlogAcpiFadtTruncatedLength"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning.*Invalid throttling state",
   "advice": "",
   "label": "KlogAcpiInvalidThrottlingState"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Warning",
   "advice": "ACPI AML intepreter has found some non-conforming AML code. This should be investigated and fixed.",
   "label": "KlogAcpiBadAmlCode"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI.*BIOS bug: multiple APIC\/MADT found, using",
   "advice": "The kernel has detected more than one ACPI Multiple APIC Description Table (MADT) (these tables have the \"APIC\" signature). There should only be one MADT and the kernel will by default select the first one. However, one can override this and select the Nth MADT using acpi_apic_instance=N.",
   "label": "KlogAcpiMultipleApicMadtFound"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "\\[Firmware Bug\\]: ACPI.*Invalid physical address in GAR",
   "advice": "ACPI Generic Address is invalid",
   "label": "KlogAcpiInvalidPhysicalAddress"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "\\[Firmware Bug\\]: powernow-k8.*(No PSB or ACPI _PSS objects|No compatible ACPI _PSS|Your BIOS does not provide ACPI _PSS objects)",
   "advice": "The _PSS object (Performance Supported States) is an optional object that indicates the number of supported processor performance states. The powernow-k8 driver source states: If you see this message, complain to BIOS manufacturer. If he tells you \"we do not support Linux\" or some similar nonsense, remember that Windows 2000 uses the same legacy mechanism that the old Linux PSB driver uses. Tell them it is broken with Windows 2000. The reference to the AMD documentation is chapter 9 in the BIOS and Kernel Developer's Guide, which is available on www.amd.com.",
   "label": "KlogAcpiAmdK8ExpectedPssObjects"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "\\[Firmware Bug\\]: powernow-k8.*Try again with latest",
   "advice": "",
   "label": "KlogAcpiTryNewAmdFirmware"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "\\[Firmware Bug\\]: ACPI.*Invalid bit width in GAR",
   "advice": "ACPI Generic Address width must be 8, 16, 32 or 64",
   "label": "KlogAcpiGarInvalidBitWidth"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "\\[Firmware Bug\\]: ACPI.*Invalid address space type in GAR",
   "advice": "ACPI Generic Address space type must be system memory or system IO space.",
   "label": "KlogAcpiGarInvalidAddressType"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "\\[Firmware Bug\\]: ACPI.*no secondary bus range in _CRS",
   "advice": "_CRS Method should return a secondary bus address for the status\/command port. The kernel is having to guess this based on the _BBN or assume it's 0x00-0xff.",
   "label": "KlogAcpiCrsSecondaryBusRangeMissing"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "\\[Firmware Bug\\]: ACPI.*Invalid BIOS _PSS frequency",
   "advice": "_PSS (Performance Supported States) package has an incorrectly define core frequency (first DWORD entry in the _PSS package).",
   "label": "KlogAcpiInvalidPssFrequency"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "No _BQC method",
   "advice": "_BQC (Brightness Query Current level) seems to be missing. This method returns the current brightness level of a built-in display output device.",
   "label": "KlogAcpiMissingBqc"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "\\[Firmware Bug\\]: ACPI.*brightness control misses _BQC function",
   "advice": "_BQC (Brightness Query Current level) seems to be missing. This method returns the current brightness level of a built-in display output device.",
   "label": "KlogAcpiMissingBqc"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "BIOS needs update for CPU frequency support",
   "advice": "Having _PPC but missing frequencies (_PSS, _PCT) is a good hint that the BIOS is older than the CPU and does not know the CPU frequencies.",
   "label": "KlogAcpiMissingPssPct"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "\\[Firmware Bug\\]: ERST.*ERST table is invalid",
   "advice": "The Error Record Serialization Table (ERST) seems to be invalid. This normally indicates that the ERST table header size is too small, or the table size (excluding header) is not a multiple of the ERST entries.",
   "label": "KlogAcpiErstInvalid"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "Invalid critical threshold",
   "advice": "ACPI _CRT (Critical Trip Point) is returning a threshold lower than zero degrees Celsius which is clearly incorrect.",
   "label": "KlogAcpiCrtInvalidThreshold"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "No valid trip found",
   "advice": "No valid ACPI _CRT (Critical Trip Point) was found.",
   "label": "KlogAcpiNoValidCrt"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "_BCQ is used instead of _BQC",
   "advice": "ACPI Method _BCQ was defined (typo) instead of _BQC - this should be fixed.however the kernel has detected this and is working around this typo.",
   "label": "KlogAcpiBcqInsteadOfBqc"
  }, 
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "MPTABLE: bad signature",
   "advice": "The MultiProcessor table has an incorrect signature, it should be PCMP. The kernel cannot trust the table and has disabled SMP support.",
   "label": "KlogBiosMptableBadSignature"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "MPTABLE: checksum error",
   "advice": "The MultiProcessor table has an incorrect checksum. The kernel cannot trust the table and has disabled SMP support.",
   "label": "KlogBiosMptableChecksumError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "MPTABLE: bad table version",
   "advice": "The MultiProcessor table has an incorrect version. It should be 0x01 or 0x04 (for versions 1.1 and 1.4 respectively). The kernel cannot trust the table and has disabled SMP support.",
   "label": "KlogBiosMptableBadVersion"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "MPTABLE: null local APIC address",
   "advice": "The MultiProcessor table contains a NULL Local APIC address but the Local APIC address must be defined. The kernel has disabled SMP support.",
   "label": "KlogBiosMptableNullLapicAddress"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "MPTABLE: no processors registered",
   "advice": "The MultiProcessor table contains no Processor Entry Fields, and hence there are no CPUs defined. The kernel has no option but to disable SMP support.",
   "label": "KlogBiosMptableNoProcessors"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "BIOS bug.*no explicit IRQ entries.*using default mptable",
   "advice": "The MultiProcessor table contains no IRQ Entry Fields, and hence there are no IRQs defined. The table is broken and should be fixed. The kernel will set up the low 16 IO-APIC pins to the ISA defaults in the hope the machine may work.",
   "label": "KlogBiosMptableNoIRQentries"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "BIOS bug.*timer not connected to IO-APIC",
   "advice": "The BIOS is reporting the ExtINTA I/O APIC input from the cascaded 8259A as the timer interrupt input.  The kernel has detected just one pin, so it has to check the timer directly and through the 8259A because of the broken BIOS reporting.",
   "label": "KlogBiosTimerNotConnectedtoIoApic"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "BIOS bug,.*IO-APIC.*ID is.*in the MPC table.*",
   "advice": "The IO-APIC id in the MPC table is wrong and the kernel has detected this and attempted to fix it. The MPC table in the firmware needs to be fixed.",
   "label": "KlogBiosIoApicInMpcTable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "BIOS bug,.*IO-APIC.*ID is already used!",
   "advice": "The IO-APIC id has been defined more than once in the MPC table, which is a firmware bug and should be fixed. The kernel has detected this and skopped this duplication to avoid stuck on smp_invalidate_needed IPI wait' messages.",
   "label": "KlogBiosIoApicIdAlreadyUsed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "WARNING.*BIOS bug.*CPU MTRRs don't cover all of memory, losing",
   "advice": "The Memory Type Range Registers (MTRRs) which define memory caching policy are misconfigued by the BIOS and don't appear to cover all available physical memory. The kernel has detected this and has reduced the amount of memory available to be safe. Either check that the BIOS memory caching options are set correctly or contact your BIOS vendor to get this fixed.",
   "label": "KlogBiosCpuMtrrMisconfigured"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "mtrr:.*no more MTRRs available",
   "advice": "A device driver has tried to allocate a Memory Type Range Register (MTRR) to optimially configure a caching policy on a memory region but there are no more free MTRRs available.  Generally the firmware should allow for one or two free MTRRs for drivers to allocate.  The system will have a sub-optimally configured memory region and this may severely impact on performance.",
   "label": "KlogBiosNoMoreMtrrsAvailable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern":  "[drm].*MTRR allocation failed.*Graphics performance may suffer",
   "advice": "The DRM driver has tried to allocate a Memory Type Range Register (MTRR) but there are no more free MTRRs available. The system will have a sub-optimally configured graphics memory region and this may severely impact on graphics rendering throughput and performance.  The firmware should allow for one or two free MTRRs, but it hasn't, which is probably a firmware bug.",
   "label": "KlogBiosMtrrAllocationFailed"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "mtrr:.*your BIOS has configured an incorrect mask, fixing it",
   "advice": "The Memory Type Range Registers (MTRRs) which define memory caching policy are misconfigued by the BIOS. In this case, the mask is incorrectly set and the kernel has detected this and worked around the firmware bug.",
   "label": "KlogBiosMtrrIncorrectMask"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "mtrr:.*your CPUs had inconsistent fixed MTRR settings",
   "advice": "The fixed Memory Type Range Registers (MTRRs) which define memory caching policy are not consistent across all CPUs which is a firmware bug. The kernel has worked around this bug, but it may be worth getting the BIOS vendor to fix this.",
   "label": "KlogBiosMtrrsInconsistentAcrossCPUs"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "mtrr:.*your CPUs had inconsistent variable MTRR settings",
   "advice": "The variable Memory Type Range Registers (MTRRs) which define memory caching policy are not consistent across all CPUs which is a firmware bug. The kernel has worked around this bug, but it may be worth getting the BIOS vendor to fix this.",
   "label": "KlogBiosMtrrsInconsistentAcrossCPUs"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "mtrr:.*your CPUs had inconsistent MTRRdefType settings",
   "advice": "The Memory Type Range Registers (MTRRs) which define memory caching policy do not have a MTRRdefType consistently set across all CPUs which is a firmware bug. The kernel has worked around this bug, but it may be worth getting the BIOS vendor to fix this.",
   "label": "KlogBiosMtrrDefTypeIncosistent"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "mtrr:.*base.*is not 4 MiB aligned",
   "advice": "The Memory Type Range Registers (MTRRs) for Intel PPro CPUs with stepping < 8 must be 4 MiB aligned and not touch 0x70000000 -> 0x7003FFFF. This BIOS misconfiguration and should be fixed.",
   "label": "KlogBiosMtrrNot4MbAligned"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITIICAL",
   "pattern": "mtrr:.*writable mtrr between 0x70000000 and 0x7003FFFF may hang the CPU",
   "advice": "The Memory Type Range Registers (MTRRs) for Intel PPro CPUs with stepping < 8 must not touch region 0x70000000 -> 0x7003FFFF. This BIOS misconfiguration may hang the CPU and should be fixed.",
   "label": "KlogBiosMtrrMayHangCPU"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "mtrr:.*base.*is not aligned on a size.*boundary",
   "advice": "The Memory Type Range Registers (MTRRs) must be correctly aligned. This BIOS misconfiguration and should be fixed.",
   "label": "KlogBiosMtrrNotAlignedCorrectly"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_LOW",
   "pattern": ".*defines _DOD but not _DOS",
   "advice": "ACPI Method _DOD (Enumerate all devices attached to display adapter) is defined but we should also have _DOS (Enable\/Disable output switching) defined but it's been omitted.",
   "label": "KlogAcpiDodWithNoDos"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "WARNING:.*bogus zero IO-APIC address found in MPTABLE",
   "advice": "An IO-APIC address of zero has been found in the MPTABLE and is thus treated as misconfigured or bogus. I/O APIC support has been disabled. This is considered a firmware bug and the MPTABLE needs to be fixed.",
   "label": "KlogAcpiBogusIoApicInMptable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "WARNING:.*Bogus.*APIC address found in table",
   "advice": "An IO-APIC address of zero has been found in the MPTABLE and is thus treated as misconfigured or bogus. I/O APIC support has been disabled. This is considered a firmware bug and the MPTABLE needs to be fixed.",
   "label": "KlogAcpiBogusIoApicInMptable"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "\\[Firmware Bug\\]:.*Duplicate ACPI video bus",
   "advice": "Try video module parameter video.allow_duplicates=1 if the current driver does't work.",
   "label": "KlogAcpiDuplicateAcpiVideoBus"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "\\[Firmware Bug\\]:.*PCI.*MMCONFIG.*not reserved in ACPI motherboard resources",
   "advice": "It appears that PCI config space has been configured for a specific device but does not appear to be reserved by the ACPI motherboard resources.",
   "label": "KlogAcpiMmconfigNotReserved"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "\\[Firmware Bug\\]: PCI.*not reserved in ACPI motherboard resources",
   "advice": "PCI firmware bug. Please see the kernel log for more details.",
   "label": "KlogPciNotReserved"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_INFO",
   "pattern": "\\[Firmware Bug\\]:.*_OSI.*Linux.*ignored",
   "advice": "This is not exactly a failure mode but a warning from the kernel. The _OSI() method has implemented a match to the 'Linux' query in the DSDT and this is redundant because the ACPI driver matches onto the Windows _OSI strings by default.",
   "label": "KlogAcpiOsiLinuxIgnored"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "\\[Firmware Bug\\]: ACPI:",
   "advice": "ACPI driver has detected an ACPI bug. This generally points to a bug in an ACPI table. Examine the kernel log for more details.",
   "label": "KlogAcpiFirmwareError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "cpu .* try to use APIC.* for vector .*, but the register is already in use for vector .* on another cpu",
   "advice": "The local vector table (LVT) offsets that provided by firmware have conflicts, the assignment to the same offset causes the second APIC setup failed.",
   "label": "KlogLVTOffsetAssignConflict"
  },  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "cpu .* try to use APIC.* for vector .*, but the register is already in use for vector .* on this cpu" ,
   "advice": "The local vector table (LVT) offsets that provided by firmware have conflicts, the assignment to the same offset causes the second APIC setup failed.",
   "label": "KlogLVTOffsetAssignConflict"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "\\[Firmware Bug\\]:.*",
   "advice": "The kernel has detected a Firmware bug in the BIOS or ACPI which needs investigating and fixing.",
   "label": "KlogAcpiFirmwareError"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "PCI.*BIOS Bug:",
   "advice": "",
   "label": "KlogBiosBug"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.*Namespace lookup failure, AE_NOT_FOUND",
   "advice": "The kernel has detected an error trying to execute an Method and it cannot find an object. This is indicates a bug in the DSDT or SSDT AML code.",
   "label": "KlogAcpiNamespaceLookupFailure"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error.+psparse",
   "advice": "The ACPI engine has failed to execute some AML. The error message above lists the method that caused this error.",
   "label": "KlogAcpiParseOrExecFailure"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "ACPI Error",
   "advice": "The kernel has most probably detected an error while executing ACPI AML. The error lists the ACPI driver module and the line number where the bug has been caught and the method that caused the error.",
   "label": "KlogAcpiExecFailure"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "No object was returned from",
   "advice": "The ACPI interpreter was requested to evaluate an ACPI namespace object and was expecting an ACPI object to be returned, but nothing was returned.  This appears to be an ACPI AML bug.",
   "label": "KlogAcpiEvalObjNoObjReturned"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Method execution failed",
   "advice": "Execution of an ACPI AML method failed. This is normally a bug in the ACPI AML code",
   "label": "KlogAcpiExecFailure"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "\\*\\*\\* Error.*Method execution failed.*AE_AML_METHOD_LIMIT",
   "advice": "ACPI method reached maximum reentrancy limit of 255 - infinite recursion in AML in DSTD or SSDT",
   "label": "KlogAcpiRecursionTooDeep"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "\\*\\*\\* Error.*Method reached maximum reentrancy limit",
   "advice": "ACPI method has reached reentrancy limit, this is a recursion bug in the AML.",
   "label": "KlogAcpiRecursionTooDeep"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "Return object type is incorrect",
   "advice": "Return object type is not the correct type, this is an AML error in the DSDT or SSDT. See also acpi_ut_evaluate_object().",
   "label": "KlogAcpiReturnObjectTypeIncorrect"
  } 
 ], 
 "pm_error_warning_patterns":
 [
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PM: Failed to prepare device",
   "advice": "dpm_prepare() failed to prepare all non-sys devices for a system PM transition. The device should be listed in the error message.",
   "label": "PmFailedToPrepareDevice"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PM: Some devices failed to power down",
   "advice": "dpm_suspend_noirq failed because some devices did not power down ",
   "label": "PmDevicesFailedToPowerDown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PM: Some system devices failed to power down",
   "advice": "sysdev_suspend failed because some system devices did not power down.",
   "label": "PmSystemDevicesFailedToPowerDown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PM: Error",
   "advice": "",
   "label": "PmError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PM: Some devices failed to power down",
   "advice": "",
   "label": "PmDevicesFailedToPowerDown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "PM: Restore failed, recovering",
   "advice": "A resume from hibernate failed when calling hibernation_restore()",
   "label": "PmResumeFromHibernateFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "PM: Resume from disk failed",
   "advice": "",
   "label": "PmResumeFromDiskFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "PM: Not enough free memory",
   "advice": "There was not enough physical memory to be able to generate a hibernation image before dumping it to disc.",
   "label": "PmNotEnoughFreeMemory"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "PM: Memory allocation failed",
   "advice": "swusp_alloc() failed trying to allocate highmem and failing that non-highmem pages for the suspend image. There is probably just not enough free physical memory available.",
   "label": "PmMemoryAllocationFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "PM: Image mismatch",
   "advice": "Mismatch in kernel version, system type, kernel release version or machine id between suspended kernel and resumed kernel.",
   "label": "PmKernelMismatch"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "PM: Some devices failed to power down",
   "advice": "",
   "label": "PmDevicesFailedToPowerDown"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "PM: Some devices failed to suspend",
   "advice": "",
   "label": "PmDevicesFailedToSuspend"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "PM: can't read",
   "advice": "Testing suspend cannot read RTC",
   "label": "PmCannotReadRealTimeClock"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "PM: can't set",
   "advice": "Testing suspend cannot set RTC",
   "label": "PmCannotSetRealTimeClock"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PM: suspend test failed, error",
   "advice": "",
   "label": "PmSuspendTestFailed"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PM: can't test ",
   "advice": "",
   "label": "PmCannotTest"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_MEDIUM",
   "pattern": "PM: no wakealarm-capable RTC driver is ready",
   "advice": "",
   "label": "PmNoWakeAlarmRealTimeClock"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "PM: Adding page to bio failed at",
   "advice": "An attempt to write the hibernate image to disk failed because a write BIO operation failed. This is usually a result of some physical hardware problem.",
   "label": "PmPhysicalDiskWriteError"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "PM: Swap header not found",
   "advice": "An attempt to write a hibernate image to disk failed because a valid swap device header could not be found. Make sure there is a formatted swap device on the machine and it is added using swapon -a.",
   "label": "PmSwapHeaderNotFound"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "PM: Cannot find swap device",
   "advice": "An attempt to write a hibernate image to disk failed because the swap device could not be found. Make sure there is a formatted swap device on the machine and it is added using swapon -a.",
   "label": "PmCannotFindSwapDevice"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_CRITICAL",
   "pattern": "PM: Not enough free swap",
   "advice": "Hibernate failed because the swap parition was probably too small.",
   "label": "PmNotEnoughFreeSwap"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PM: Image device not init",
   "advice": "",
   "label": "PmImageDeviceNotInitialised"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "PM: Please power down manually",
   "advice": "",
   "label": "PMPowerDownManually"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "check_for_bios_corruption",
   "advice": "The BIOS seems to be corrupting the first 64K of memory when doing suspend\/resume. Setting bios_corruption_check=0 will disable this check.",
   "label": "PmBiosCorruptFirst64K"
  },
  {
   "compare_mode": "regex",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "WARNING: at.*hpet_next_event",
   "advice": "Possibly an Intel I\/O controller hub HPET Write Timing issue: A read transaction that immediately follows a write transaction to the HPET TIMn_COMP Timer 0 (108h), HPET MAIN_CNT (0F0h), or TIMn_CONF.bit 6 (100h) may return an incorrect value.  This is known to cause issues when coming out of S3.",
   "label": "PmHpetWriteTimingIssue"
  },
  {
   "compare_mode": "string",
   "log_level": "LOG_LEVEL_HIGH",
   "pattern": "BUG: soft lockup.*stuck for 0s",
   "advice": "Softlock errors that occur when coming out of S3 may be tripped by TSC warping.  It may be worth trying the notsc kernel parameter and repeating S3 tests to see if this solves the problem.",
   "label": "PmProcessSoftLockup"
  }
 ] 
}
